设置
{
	主程序
	{
		描述: "▶ 斩仇跑酷编辑器 v1.0.3A\r\n\r\n代码: J4GF6\r\n维护: 十六 , 芒果鲨\r\n\r\n斩仇跑酷交流群：614016408"
		模式名称: "Vendetta Parkour - 斩仇跑酷"
	}
	大厅
	{
		比赛结束后转换队伍: 否
		玩家上限 队伍1: 11
		玩家上限 队伍2: 0
		观战者人数上限: 12
		返回大厅: 从不
		队列中的玩家可以加入: 是
	}
	模式
	{
		团队死斗
		{
			启用地图
			{
			}
			主动复生: 关闭
		}
		突击模式
		{
			启用地图
			{
				地图工坊室内
			}
		}
		综合
		{
			允许切换英雄: 关闭
			启用威能: 关闭
			复生时间: 0%
			敌方生命条: 关闭
			消灭提示: 关闭
			游戏模式开始: 即时
			英雄限制: 关闭
			阵亡镜头: 关闭
			随机英雄复生: 开启
		}
	}
	英雄
	{
		综合
		{
			斩仇
			{
				旋风疾步冷却时间: 0%
				飞空斩击冷却时间: 65%
			}
			
			启用英雄
			{
				斩仇
			}
		}
	}
	扩展
	{
		播放更多效果
		爆炸声音
	}
}


变量
{
	全局:
		4: TimeRemaining
		5: PortalEffects
		12: Dao
		13: SHIFT
		14: EditSelected
		15: EditSelectIdArray
		16: EditorOn
		18: TQ
		20: TQ2
		21: EditorMoveItem
		22: EditMode
		23: TQ5
		24: TQ6
		25: BounceToggleLock
		26: killballnumber
		27: pinballnumber
		30: maprating
		32: LeaderBoardFull
		33: LeaderBoardHuds
		34: LeaderBoardRemake
		38: NANBA
		40: PortalNames
		41: PortalLoc
		42: PortalDest
		43: PortalOn
		44: Difficultyhud
		45: CustomPortalStart
		46: CustomPortalEndpoint
		47: CustomPortalCP
		50: CompMode
		51: CompTime
		52: CompAtmpNum
		53: CompAtmpSaveNames
		54: CompAtmpSaveCount
		55: CompRestartLimit
		56: instructiontext
		57: TitleData
		60: SaveName
		61: SaveCp
		62: SaveEnt
		63: SaveTimer
		64: SaveElapsed
		67: HintCp
		68: HintText
		69: ColorConfig
		70: Name
		71: Code
		73: Cachedcredits
		74: CpHudText
		75: CpHudCp
		76: CpIwtText
		77: CpIwtCp
		78: CpIwtPos
		79: CpIwtColor
		85: BanDead
		86: BanBhop
		87: BanStand
		91: MapVectorArray
		100: Ability2
		102: TQ7
		105: UnlimitAbilities

	玩家:
		0: lockState
		1: checkpoint_current
		2: checkpoint_practice
		3: checkpoint_moved
		4: checkpoint_notLast
		5: checkpoint_skip
		6: timer_normal
		7: timer_practice
		10: toggle_invincible
		11: toggle_spectate
		12: toggle_practice
		13: toggle_quickRestart
		14: toggle_guide
		15: toggle_leaderboard
		16: toggle_invisible
		17: toggle_hints
		18: skill_countBhops
		19: skill_usedHop
		20: skill_countCreates
		21: skill_countMulti
		22: skill_usedClimb
		23: skill_usedBhop
		25: banString
		30: ban_dead
		31: ban_bhop
		32: ban_standcreate
		33: count_restart
		35: cache_startUlt
		36: cache_startAbility1
		37: cache_collectedLocks
		38: cache_bounceTouched
		39: cache_portalStart
		40: cache_portalEnd
		41: cache_bounceMaxLocks
		42: cache_killPosition
		43: cache_killRadii
		44: cache_bouncePosition
		45: cache_inputs
		46: cache_rainbow
		47: cache_titleHud
		48: preview_array1
		49: preview_array2
		50: preview_i
		51: editor_modeSelect
		52: editor_fly
		53: editor_saveCache
		54: editor_undo
		55: editor_lock
		56: editor_hitboxEffect
		57: editor_hitboxToggle
		58: editor_bounceIndex
		59: editor_killIndex
		60: editor_temp
		61: comp_countAttempts
		62: comp_instructionHud
		63: addon_toggle3rdPov
		64: maprating
		100: cache_startAbility2
		101: cache_startSecondary
}

子程序
{
	0: StartGame
	1: LeaderboardUpdate
	2: CheckpointFailReset
	3: UpdateTitle
	4: ResetAbilities
	5: UpdateCache
	6: DeleteSave
	7: MakeSave
	8: TimerPause
	9: TimerResume
	10: EditUpdateSelectedIds
	11: AddonCustomLoadAndReset
	13: Addon3rdPerson
	14: RebuildKillOrbs
	15: RebuildPortals
	16: RebuildBounceOrbs
}

规则("Disable inspector")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		禁用查看器录制;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Parkour v1.0.3A ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Parkour | Setup & Variables")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"◀ Vendetta Parkour Editor ▶\nCode: J4GF6\nAdapted by: 十六#52327"
		关闭游戏预设完成条件;
		关闭游戏预设计分模式;
		关闭游戏预设音乐模式;
		关闭游戏预设通告模式;
		开始强制重生室(所有队伍, 假);
		开始强制重生室(所有队伍, 1);
		开始强制重生室(所有队伍, 2);
		等待(0.512, 无视条件);
		// 全局.radius_fx = 地图工坊设置实数(自定义字符串("Radius Settings    ◆ 点位半径"), 自定义字符串("Radius fx                  ◆ 实际判断半径(推荐默认)"), 1.800, 1, 3, 0);
		// 全局.radius_effect = 地图工坊设置实数(自定义字符串("Radius Settings    ◆ 点位半径"), 自定义字符串("Radius effect         ◆ 视觉效果半径(推荐默认)"), 1.400, 1, 3, 1);
		// 全局.radius_effect = 全局.radius_fx - 0.4;
		全局.EditorOn = 地图工坊设置开关(自定义字符串("Map Settings      ◆ 地图设置"), 自定义字符串("Editor Mode         ◆ 作图模式"), 真, 0);
		全局.PortalOn = 地图工坊设置开关(自定义字符串("Map Settings      ◆ 地图设置"), 自定义字符串("Portals 󠀨Control Maps󠀩    ◆ 启用传送门 󠀨占点地图󠀩"), 真, 4);

		// 隐藏竞赛模式工坊设置

		// 全局.CompMode = !全局.EditorOn && 地图工坊设置开关(自定义字符串("Tournament Mode   ◆ 竞赛模式"), 自定义字符串("Tournament Mode        ◆ 开启竞赛模式"), 假, 100);
		// If(全局.CompMode);
		// 	全局.CompTime = 地图工坊设置整数(自定义字符串("Tournament Mode   ◆ 竞赛模式"), 自定义字符串("Time Limit 󠀨Global󠀩      ◆ 时间限制󠀩"), 1, 240, 120, 101);
		// 	全局.CompAtmpNum = 地图工坊设置整数(自定义字符串("Tournament Mode   ◆ 竞赛模式"), 自定义字符串("Attempt Count         ◆ 尝试次数"), 0, 500, 5, 102);
		// 	全局.CompRestartLimit = 地图工坊设置开关(自定义字符串("Tournament Mode   ◆ 竞赛模式"), 自定义字符串("Disable Restart During Run ◆ 竞赛中禁用重新开始"), 假, 103);
		// Else;
		全局.instructiontext = 空;
		// End;

		全局.SaveName = 空数组;
		全局.SaveCp = 空数组;
		全局.SaveTimer = 空数组;
		全局.SaveEnt = 空数组;
		全局.SaveElapsed = 空数组;
		全局.Dao = 数量(全局.Dao) ? 已过滤的数组(全局.Dao, 当前数组元素 + 假 >= 空) : 空数组;
		全局.SHIFT = 数量(全局.SHIFT) ? 已过滤的数组(全局.SHIFT, 当前数组元素 + 假 >= 空) : 空数组;
		全局.Ability2 = 数量(全局.Ability2) ? 已过滤的数组(全局.Ability2, 当前数组元素 + 假 >= 空) : 空数组;
		全局.UnlimitAbilities = 数量(全局.UnlimitAbilities) ? 已过滤的数组(全局.UnlimitAbilities, 当前数组元素 + 假 >= 空) : 空数组;
		全局.pinballnumber = 数量(全局.pinballnumber) ? 全局.pinballnumber : 空数组;
		全局.A = 数量(全局.A) ? 全局.A : 空数组;
		全局.A = 数量(全局.A) ? 全局.A : 空数组;
		全局.killballnumber = 数量(全局.killballnumber) ? 全局.killballnumber : 空数组;
		全局.H = 数量(全局.H) ? 全局.H : 空数组;
		全局.I = 数量(全局.I) ? 全局.I : 空数组;
		全局.K = 数量(全局.K) ? 全局.K : 空数组;
		全局.TQ = 数量(全局.TQ) ? 全局.TQ : 空数组;
		全局.TQ2 = 数量(全局.TQ2) ? 全局.TQ2 : 空数组;
		全局.EditMode = 数量(全局.EditMode) ? 全局.EditMode : 空数组;
		全局.TQ5 = 数量(全局.TQ5) ? 全局.TQ5 : 空数组;
		全局.TQ6 = 数量(全局.TQ6) ? 全局.TQ6 : 空数组;
		全局.TQ7 = 数量(全局.TQ7) ? 全局.TQ7 : 空数组;
		全局.BounceToggleLock = 数量(全局.BounceToggleLock) ? 全局.BounceToggleLock : 空数组;
		全局.CustomPortalStart = 数量(全局.CustomPortalStart) ? 全局.CustomPortalStart : 空数组;
		全局.CustomPortalEndpoint = 数量(全局.CustomPortalEndpoint) ? 全局.CustomPortalEndpoint : 空数组;
		全局.CustomPortalCP = 数量(全局.CustomPortalCP) ? 全局.CustomPortalCP : 空数组;
		全局.LeaderBoardFull = 空数组;
		全局.TitleData = 空;
		全局.HintCp = 空数组;
		全局.HintText = 空数组;
		"clean out -1's after the ban has loaded"
		全局.BanDead = 数量(全局.BanDead) ? 已过滤的数组(全局.BanDead, 当前数组元素 + 假 >= 空) : 空数组;
		全局.BanBhop = 数量(全局.BanBhop) ? 已过滤的数组(全局.BanBhop, 当前数组元素 + 假 >= 空) : 空数组;
		全局.BanStand = 数量(全局.BanStand) ? 已过滤的数组(全局.BanStand, 当前数组元素 + 假 >= 空) : 空数组;
		
		"fix team because of naming"
		If(全局.ColorConfig[16] == 颜色(队伍1));
			全局.ColorConfig[16] = 颜色(蓝色);
		Else If(全局.ColorConfig[16] == 颜色(队伍2));
			全局.ColorConfig[16] = 颜色(红色);
		End;
		"prevent same color lock orbs"
		If(全局.ColorConfig[15] == 全局.ColorConfig[16]);
			全局.ColorConfig[16] = 全局.ColorConfig[15] == 颜色(橙色) ? 颜色(绿色) : 颜色(橙色);
		End;
		"prevent same color bhop/climb used/unused"
		If(全局.ColorConfig[7] == 全局.ColorConfig[8]);
			全局.ColorConfig[8] = 全局.ColorConfig[7] == 颜色(红色) ? 颜色(橙色) : 颜色(红色);
		End;
		全局.maprating[0] = 地图工坊设置开关(自定义字符串("Map Rating                         ◆ 地图评分"), 自定义字符串("Rating Enable                              ◆ 评分开关"), 真, 0);
		全局.maprating[1] = 0;
		全局.maprating[2] = 0;
		全局.maprating[3] = 空数组;
	}
}

规则("Parkour | Match time")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		If(当前游戏模式 != 游戏模式(突击模式));
			等待(假, 无视条件);
			设置比赛时间(假);
			等待(假, 无视条件);
			设置比赛时间(假);
			等待(假, 无视条件);
		End;
		设置比赛时间(70);
		比赛时间暂停;
		等待(假, 无视条件);
		全局.TimeRemaining = 265;
		While(全局.TimeRemaining);
			等待(60, 无视条件);
			全局.TimeRemaining -= 真;
			If(全局.CompMode);
				全局.CompTime -= 真;
				If(!全局.CompTime);
					大字体信息(首个(真), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("时间到了") : 自定义字符串("Time's Up"));
					停止追踪玩家变量(所有玩家(所有队伍), timer_normal);
					设置受到伤害(所有玩家(所有队伍), 100);
					击杀(所有玩家(所有队伍), 空);
				End;
			End;
		End;
		大字体信息(首个(真), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("房间已达最大持续时间, 即将重启") : 自定义字符串("Maximum Lobby Time Reached, Restarting"));
		等待(5, 无视条件);
		"Prevent crash during POTG and closing lobby"
		所有玩家(所有队伍).lockState = 真;
		宣告玩家胜利(主机玩家);
		宣告队伍胜利(所在队伍(主机玩家));
	}
}

规则("Parkour | Player Initialize")
{
	事件
	{
		玩家加入比赛;
		双方;
		全部;
	}

	动作
	{
		隐藏游戏模式HUD(事件玩家);
		隐藏姓名板(所有玩家(所有队伍), 所有玩家(所有队伍));
		取消与玩家的移动碰撞(事件玩家);
		设置受到伤害(事件玩家, 0);
		事件玩家.lockState = 真;
		根据条件中止(是否是机器人(事件玩家));
		对所有玩家启用死亡回放(事件玩家);
		启用死亡回放时目标的HUD(事件玩家);
		关闭游戏预设复生模式(事件玩家);
		"Preload Hero - Vendetta"
		预加载英雄(事件玩家, 英雄(斩仇));
		事件玩家.editor_lock = 真;
		事件玩家.toggle_guide = 真;
		"eventPlayer.toggle_quickRestart = true"
		事件玩家.cache_bounceTouched = -1;
		"big waits first for about 1 second before loading, to make sure things like comp mode are fully loaded and configured, load fx in meanwhile"
		等待(真, 无视条件);
		创建效果(事件玩家, 环, 全局.ColorConfig[9], 最后(全局.A[事件玩家.checkpoint_current]), 1.4, 位置和半径);
		创建效果(事件玩家.checkpoint_notLast ? 事件玩家 : 空, 环, 全局.ColorConfig[10], 全局.A[事件玩家.checkpoint_current + 真], 1.4, 可见，位置和半径);
		创建效果(事件玩家.checkpoint_notLast ? 事件玩家 : 空, 光柱, 全局.ColorConfig[11], 全局.A[事件玩家.checkpoint_current + 真], 1.4, 可见，位置和半径);
		创建图标(事件玩家.checkpoint_notLast ? 事件玩家 : 空, 全局.A[事件玩家.checkpoint_current + 真] + 上, 箭头：向下, 可见和位置, 全局.ColorConfig[12], 真);
		等待直到 (已重生(事件玩家), 999999995904.000);
		事件玩家.editor_lock = 假;
		If(全局.CompMode);
			设置不可见(事件玩家, 全部);
			If(数组包含(全局.CompAtmpSaveNames, 字符串分割(首个(事件玩家), 空数组)));
				事件玩家.comp_countAttempts = 全局.CompAtmpSaveCount[数组值的索引(全局.CompAtmpSaveNames, 字符串分割(首个(事件玩家), 空数组))];
			"instructions and settings for comp start"
			Else;
				事件玩家.comp_instructionHud = 真;
				修改全局变量(CompAtmpSaveNames, 添加至数组, 字符串分割(首个(事件玩家), 空数组));
				修改全局变量(CompAtmpSaveCount, 添加至数组, 1);
				事件玩家.comp_countAttempts = 1;
				设置移动速度(事件玩家, 假);
				设置启用技能 1(事件玩家, 假);
				设置启用终极技能(事件玩家, 假);
				等待直到 (!按钮被按下(事件玩家, 按钮(互动)), 真);
				等待直到 (按钮被按下(事件玩家, 按钮(互动)) || 全局.CompTime < 1, 999999995904.000);
				设置移动速度(事件玩家, 100);
				事件玩家.comp_instructionHud = 假;
			End;
			If(全局.CompTime < 1 || 事件玩家.comp_countAttempts < 空);
				事件玩家.toggle_leaderboard = 真;
				事件玩家.comp_countAttempts = -1;
				设置受到伤害(事件玩家, 100);
				击杀(事件玩家, 空);
				设置受到伤害(事件玩家, 0);
				中止;
			End;
		End;
		等待(假, 无视条件);
		设置状态(事件玩家, 空, 无敌, 99999);
		If(全局.EditorOn == 假);
			事件玩家.toggle_invisible = 真;
			设置不可见(事件玩家, 全部);
		End;
		"initialization of the game"
		调用子程序(StartGame);
		事件玩家.lockState = 假;
	}
}

规则("Parkour | Player Leaves")
{
	事件
	{
		玩家离开比赛;
		双方;
		全部;
	}

	动作
	{
		If(全局.SaveCp[数组值的索引(全局.SaveEnt, 事件玩家)]);
			If(全局.SaveCp[数组值的索引(全局.SaveEnt, 事件玩家)] < 数量(全局.A) - 真 && 全局.SaveElapsed[数组值的索引(全局.SaveEnt, 事件玩家)]);
				全局.SaveTimer[数组值的索引(全局.SaveEnt, 事件玩家)] = 总计消耗时间 - 全局.SaveElapsed[数组值的索引(全局.SaveEnt, 事件玩家)] + 全局.SaveTimer[数组值的索引(全局.SaveEnt, 事件玩家)
					];
			End;
		"delete if player didnt do first cp"
		Else;
			调用子程序(DeleteSave);
	}
}

规则("Parkour | Arrive")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lockState == 假;
		// 在地面上(事件玩家) == 真;
		存活(事件玩家) == 真;
		(事件玩家.toggle_invincible || 事件玩家.toggle_spectate) == 假;
		事件玩家.checkpoint_notLast != 假;
		相距距离(事件玩家, 全局.A[事件玩家.checkpoint_current + 真]) <= 1.8;
	}

	动作
	{
		"arrived ----------------------------------------------------------------------------------------------------"
		If(数量(事件玩家.cache_collectedLocks) < 事件玩家.cache_bounceMaxLocks);
			小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   ! 进点前需集齐所有收集球 !") : 自定义字符串("   ! Collect All {0} Orbs To Complete !",
				全局.ColorConfig[16]));
			"kill player if not colleted the locks"
			调用子程序(CheckpointFailReset);
		Else If(事件玩家.ban_bhop && 事件玩家.skill_usedBhop);
			小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   ↓ 留小跳进点!") : 自定义字符串("   ≥ Must Have A Bhop To Complete!"));
			调用子程序(CheckpointFailReset);
		Else;
			事件玩家.checkpoint_moved = 真;
			事件玩家.checkpoint_current += 真;
			If(!事件玩家.toggle_practice);
				调用子程序(DeleteSave);
				"complete lvl"
				If(事件玩家.checkpoint_current == 数量(全局.A) - 真 && !全局.EditorOn);
					停止追踪玩家变量(事件玩家, timer_normal);
					调用子程序(LeaderboardUpdate);
					If(全局.CompMode && 全局.CompAtmpNum);
						If(事件玩家.comp_countAttempts == 全局.CompAtmpNum);
							全局.CompAtmpSaveCount[数组值的索引(全局.CompAtmpSaveNames, 字符串分割(首个(事件玩家), 空数组))] = -1;
							事件玩家.comp_countAttempts = -1;
							事件玩家.toggle_leaderboard = 真;
							设置受到伤害(事件玩家, 100);
							击杀(事件玩家, 空);
							设置受到伤害(事件玩家, 0);
						Else;
							全局.CompAtmpSaveCount[数组值的索引(全局.CompAtmpSaveNames, 字符串分割(首个(事件玩家), 空数组))] = 事件玩家.comp_countAttempts + 真;
						End;
					End;
					大字体信息(首个(真), 自定义字符串("{0} {1} {2} sec", 事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("恭喜！已通关! 用时") : 自定义字符串("Mission complete! Time"),
						事件玩家.timer_normal));
					If(!数组包含(全局.maprating[3], 首个(事件玩家)) && 全局.maprating);
						事件玩家.maprating[0] = 真;
					End;
					等待(假, 无视条件);
				"update save"
				Else;
					调用子程序(MakeSave);
				End;
				调用子程序(UpdateTitle);
			End;
			调用子程序(UpdateCache);
			"teleport cps"
			If(数量(全局.A[事件玩家.checkpoint_current]) > 1);
				调用子程序(CheckpointFailReset);
			Else;
				调用子程序(ResetAbilities);
				调用子程序(AddonCustomLoadAndReset);
			End;
			等待(假, 无视条件);
			播放效果(事件玩家, 环状爆炸声音, 空, 事件玩家, 100);
			播放效果(全局.CompMode || 事件玩家.toggle_invisible ? 事件玩家 : 真, 环状爆炸, 颜色(天蓝色), 所选位置(事件玩家), 4);
		End;
		事件玩家.cache_collectedLocks = 空数组;
		等待(0.048, 无视条件);
	}
}

规则("Parkour | Reset")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.lockState == 假;
		在地面上(事件玩家) == 真;
		存活(事件玩家) == 真;
		事件玩家.checkpoint_notLast != 假;
	}

	动作
	{
		事件玩家.cache_collectedLocks = 空数组;
		If((相距距离(事件玩家, 最后(全局.A[事件玩家.checkpoint_current])) > 1.8) && !(事件玩家.toggle_invincible || 事件玩家.toggle_spectate));
			调用子程序(CheckpointFailReset);
		End;
		等待(0.048, 无视条件);
		如条件为“真”则循环;
	}
}

规则("Parkour | Boundary Sphere")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.cache_killPosition != 空数组;
		事件玩家.toggle_invincible == 假;
		事件玩家.checkpoint_notLast != 假;
		对任意为“真”(事件玩家.cache_killRadii, 归一化(当前数组元素) * 相距距离(事件玩家.cache_killPosition[当前数组索引], 事件玩家) < 当前数组元素) == 真;
	}

	动作
	{
		调用子程序(CheckpointFailReset);
	}
}

规则("Parkour | Bounce Ball / Orb")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.cache_bouncePosition != 空数组;
		"@Condition eventPlayer.checkpoint_notLast # disabled coz editor"
		对任意为“真”(事件玩家.cache_bouncePosition, 相距距离(当前数组元素, 所选位置(事件玩家) + 0.700 * 上) < 1.400) == 真;
	}

	动作
	{
		事件玩家.cache_bounceTouched = 数组值的索引(全局.TQ, 已过滤的数组(全局.TQ,
			全局.pinballnumber[当前数组索引] == 事件玩家.checkpoint_current && 当前数组索引 != 事件玩家.cache_bounceTouched && !数组包含(事件玩家.cache_collectedLocks,
			当前数组索引) && 相距距离(事件玩家 + 0.700 * 上, 当前数组元素) < 1.400));
		"prevent same one activating twice in a row"
		If(事件玩家.cache_bounceTouched >= 空);
			If(全局.BounceToggleLock[事件玩家.cache_bounceTouched]);
				修改玩家变量(事件玩家, cache_collectedLocks, 添加至数组, 事件玩家.cache_bounceTouched);
				小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   弹球已收集") : 自定义字符串("   Collected Orb"));
			End;
			If(全局.EditMode[事件玩家.cache_bounceTouched] != 空);
				施加推力(事件玩家, 上, 全局.EditMode[事件玩家.cache_bounceTouched], 至地图, 取消相反运动XYZ);
			End;
			If(全局.TQ5[事件玩家.cache_bounceTouched]);
				设置启用终极技能(事件玩家, 真);
				设置终极技能充能(事件玩家, 100);
				小字体信息(事件玩家, 自定义字符串("   {0} {1} ", 技能图标字符串(所用英雄(事件玩家), 按钮(终极技能)), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("终极技能已就绪") : 自定义字符串(
					"Ultimate Is Ready")));
			End;
			If(全局.TQ6[事件玩家.cache_bounceTouched]);

				设置启用技能 1(事件玩家, 真);
				小字体信息(事件玩家, 自定义字符串("   {0} {1} ", 技能图标字符串(所用英雄(事件玩家), 按钮(技能1)), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("技能1已就绪") : 自定义字符串(
					"Ability 1 Is Ready")));
			End;
			If(全局.TQ7[事件玩家.cache_bounceTouched]);
				设置启用技能 2(事件玩家, 真);
				小字体信息(事件玩家, 自定义字符串("   {0} {1} ", 技能图标字符串(所用英雄(事件玩家), 按钮(技能2)), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("技能2已就绪") : 自定义字符串(
					"Ability 2 Is Ready")));
			End;
			播放效果(事件玩家, 状态爆炸声音, 空, 事件玩家, 75);
		End;
		等待(0.240, 无视条件);
		如条件为“真”则循环;
		事件玩家.cache_bounceTouched = -1;
	}
}

规则("Parkour | Death Reset")
{
	事件
	{
		玩家阵亡;
		双方;
		全部;
	}

	条件
	{
		是否是机器人(事件玩家) == 假;
		死亡(事件玩家) == 真;
		事件玩家.toggle_spectate == 假;
		事件玩家.comp_countAttempts >= 空;
	}

	动作
	{
		If(数量(全局.A));
			复活(事件玩家);
		Else;
			复生(事件玩家);
		End;
		调用子程序(CheckpointFailReset);
		"rest is to prevent dead spamming from crashing server\nbut doing waits only when needed without relying on a variable count"
		等待直到 (存活(事件玩家), 真);
		等待直到 (死亡(事件玩家), 真);
		如条件为“假”则中止;
		等待(0.160, 无视条件);
		复活(事件玩家);
		调用子程序(CheckpointFailReset);
		等待直到 (存活(事件玩家), 真);
		等待直到 (死亡(事件玩家), 真);
		如条件为“假”则中止;
		等待(0.440, 无视条件);
		复活(事件玩家);
		调用子程序(CheckpointFailReset);
		等待直到 (存活(事件玩家), 真);
		等待直到 (死亡(事件玩家), 真);
		如条件为“假”则中止;
		等待(真, 无视条件);
		复生(事件玩家);
		调用子程序(CheckpointFailReset);
	}
}

规则("Parkour | SUB Update Effect Cache")
{
	事件
	{
		子程序;
		UpdateCache;
	}

	动作
	{
		"note: if adding cp pos to cache, make sure to also adjust editor things like move and teleport"
		事件玩家.cache_bouncePosition = 已过滤的数组(全局.TQ, 全局.pinballnumber[当前数组索引] == 事件玩家.checkpoint_current);
		事件玩家.cache_bounceMaxLocks = 数量(已过滤的数组(全局.BounceToggleLock, 全局.pinballnumber[当前数组索引] == 事件玩家.checkpoint_current && 当前数组元素));
		事件玩家.cache_killPosition = 已过滤的数组(全局.H, 全局.killballnumber[当前数组索引] == 事件玩家.checkpoint_current);
		事件玩家.cache_killRadii = 已过滤的数组(全局.I, 全局.killballnumber[当前数组索引] == 事件玩家.checkpoint_current);
		事件玩家.cache_portalStart = 已过滤的数组(全局.CustomPortalStart,
			全局.CustomPortalCP[当前数组索引] == 事件玩家.checkpoint_current || 全局.CustomPortalCP[当前数组索引] < 空);
		事件玩家.cache_portalEnd = 已过滤的数组(全局.CustomPortalEndpoint,
			全局.CustomPortalCP[当前数组索引] == 事件玩家.checkpoint_current || 全局.CustomPortalCP[当前数组索引] < 空);
		事件玩家.checkpoint_notLast = 事件玩家.checkpoint_current < 数量(全局.A) - 真 && 数量(全局.A) > 1;
		事件玩家.cache_startUlt = 数组包含(全局.Dao, 事件玩家.checkpoint_current) || !事件玩家.checkpoint_notLast;
		事件玩家.cache_startAbility1 = 数组包含(全局.SHIFT, 事件玩家.checkpoint_current) || !事件玩家.checkpoint_notLast;
		事件玩家.cache_startAbility2 = 数组包含(全局.Ability2, 事件玩家.checkpoint_current) || !事件玩家.checkpoint_notLast;
		事件玩家.toggle_hints = 假;
		事件玩家.banString = 空数组;
		等待(假, 无视条件);
		If(事件玩家.checkpoint_notLast);
			事件玩家.ban_dead = 地图工坊设置开关(自定义字符串("Ban (All Levels)             ◆ 封禁(应用于所有关卡)"), 自定义字符串("Ban DeadUsingAbility2    ◆ 封禁死亡E"), 假, 0)
				|| 数组包含(全局.BanDead, 事件玩家.checkpoint_current);
			If(事件玩家.ban_dead);
				"♂"
				事件玩家.banString = 自定义字符串("♂");
			End;
			事件玩家.ban_standcreate = 地图工坊设置开关(自定义字符串("Ban (All Levels)             ◆ 封禁(应用于所有关卡)"), 自定义字符串("Ban StandCreate        ◆ 封禁卡小跳"), 假, 1)
				|| 数组包含(全局.BanStand, 事件玩家.checkpoint_current);
			If(事件玩家.ban_standcreate);
				"× ♂"
				事件玩家.banString = 自定义字符串("×");
			End;
			事件玩家.ban_bhop = 地图工坊设置开关(自定义字符串("Ban (All Levels)             ◆ 封禁(应用于所有关卡)"), 自定义字符串("Require Bhop Available     ◆ 留小跳进点"), 假, 2)
				|| 数组包含(全局.BanBhop, 事件玩家.checkpoint_current);
			If(事件玩家.ban_bhop);
				"↓ × ♂"
				事件玩家.banString = 自定义字符串("↓ {0}", 事件玩家.banString);
			End;
		Else;
			事件玩家.ban_standcreate = 假;
			事件玩家.ban_bhop = 假;
		End;
		等待(假, 无视条件);
		根据条件中止(!全局.EditorOn || 事件玩家 != 主机玩家);
		调用子程序(EditUpdateSelectedIds);
		消除效果(主机玩家.editor_hitboxEffect);
		创建效果(主机玩家.editor_hitboxToggle ? 主机玩家 : 空, 球体, 颜色(白色), 全局.A[主机玩家.checkpoint_current], 1.8, 可见，位置和半径);
		主机玩家.editor_hitboxEffect = 最后创建的实体;
		创建效果(主机玩家.editor_hitboxToggle && 主机玩家.checkpoint_notLast ? 主机玩家 : 空, 球体, 颜色(白色), 全局.A[主机玩家.checkpoint_current + 真], 1.8,
			可见，位置和半径);
		修改玩家变量(主机玩家, editor_hitboxEffect, 添加至数组, 最后创建的实体);
		主机玩家.editor_bounceIndex = 已过滤的数组(映射的数组(全局.pinballnumber, 当前数组元素 == 主机玩家.checkpoint_current ? 当前数组索引 : -1), 当前数组元素 >= 空);
		主机玩家.editor_killIndex = 已过滤的数组(映射的数组(全局.killballnumber, 当前数组元素 == 主机玩家.checkpoint_current ? 当前数组索引 : -1), 当前数组元素 >= 空);
		If(主机玩家.checkpoint_moved);
			全局.EditSelected = 最后(全局.EditSelectIdArray);
			主机玩家.checkpoint_moved = 假;
		End;
	}
}

规则("Parkour | SUB Delete Save")
{
	事件
	{
		子程序;
		DeleteSave;
	}

	动作
	{
		修改全局变量(SaveName, 根据索引从数组中移除, 数组值的索引(全局.SaveEnt, 事件玩家));
		修改全局变量(SaveCp, 根据索引从数组中移除, 数组值的索引(全局.SaveEnt, 事件玩家));
		修改全局变量(SaveTimer, 根据索引从数组中移除, 数组值的索引(全局.SaveEnt, 事件玩家));
		修改全局变量(SaveElapsed, 根据索引从数组中移除, 数组值的索引(全局.SaveEnt, 事件玩家));
		"must always be last because its the index itself"
		修改全局变量(SaveEnt, 根据索引从数组中移除, 数组值的索引(全局.SaveEnt, 事件玩家));
	}
}

规则("Parkour | SUB Make Save")
{
	事件
	{
		子程序;
		MakeSave;
	}

	动作
	{
		修改全局变量(SaveEnt, 添加至数组, 事件玩家);
		修改全局变量(SaveName, 添加至数组, 字符串分割(首个(事件玩家), 空数组));
		修改全局变量(SaveCp, 添加至数组, 事件玩家.checkpoint_current);
		修改全局变量(SaveTimer, 添加至数组, 事件玩家.timer_normal);
		修改全局变量(SaveElapsed, 添加至数组, 总计消耗时间);
	}
}

规则("Parkour | SUB Timer Pause")
{
	事件
	{
		子程序;
		TimerPause;
	}

	动作
	{
		停止追踪玩家变量(事件玩家, timer_normal);
		根据条件中止(!数组包含(全局.SaveEnt, 事件玩家));
		全局.SaveTimer[数组值的索引(全局.SaveEnt, 事件玩家)] = 事件玩家.timer_normal;
		全局.SaveElapsed[数组值的索引(全局.SaveEnt, 事件玩家)] = 空;
	}
}

规则("Parkour | SUB Timer Resume")
{
	事件
	{
		子程序;
		TimerResume;
	}

	动作
	{
		追踪玩家变量频率(事件玩家, timer_normal, 999999995904.000, 真, 全部禁用);
		全局.SaveElapsed[数组值的索引(全局.SaveEnt, 事件玩家)] = 总计消耗时间;
	}
}

规则("Parkour | SUB Leaderboard Update")
{
	事件
	{
		子程序;
		LeaderboardUpdate;
	}

	动作
	{
		"[[Hero][name, seconds, prettytime]]\nyou already have a time"
		If(数组包含(映射的数组(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))], 首个(当前数组元素)), 字符串分割(首个(事件玩家), 空数组)));
			根据条件中止(事件玩家.timer_normal >= 首个(已过滤的数组(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))], 首个(当前数组元素) == 字符串分割(首个(事件玩家), 空数组)))[真]);
			全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))] = 已过滤的数组(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))], 首个(当前数组元素) != 字符串分割(首个(事件玩家),
				空数组));
		Else If(数量(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))]) < 25 || 事件玩家.timer_normal < 全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))
				][24][真]);
			全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))] = 已过滤的数组(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))], 当前数组索引 < 24);
		Else;
			"Full and time too slow"
			中止;
		End;
		If(!全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))]);
			全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))] = 数组(数组(字符串分割(首个(事件玩家), 空数组), 事件玩家.timer_normal, 自定义字符串("{0} sec",
				事件玩家.timer_normal)));
		Else;
			全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))] = 添加至数组(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(事件玩家))], 数组(数组(字符串分割(首个(事件玩家), 空数组),
				事件玩家.timer_normal, 自定义字符串("{0} sec", 事件玩家.timer_normal))));
		End;
		"CreateLeaderboard()"
		全局.LeaderBoardRemake = 所用英雄(事件玩家);
	}
}

规则("Parkour | SUB Checkpoint Fail")
{
	事件
	{
		子程序;
		CheckpointFailReset;
	}

	动作
	{
		事件玩家.cache_collectedLocks = 空数组;
		"Vendetta Using Ability 2"
		根据条件跳过(正在使用技能 2(事件玩家), 真);
		取消主要动作(事件玩家);
		If(!(事件玩家.checkpoint_current || 事件玩家.toggle_practice));
			事件玩家.timer_normal = 空;
		End;
		If(数量(全局.A));
			// If(正在使用技能 1(事件玩家));
			// 	开始强制设置玩家位置(事件玩家, 事件玩家, 假);
			// 	等待直到 (!正在使用技能 1(事件玩家), 真);
			// 	等待(假, 无视条件);
			// 	停止强制设置玩家位置(事件玩家);
			// End;
			If(正在使用技能 2(事件玩家) && 事件玩家.ban_dead);
				小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   死亡E ♂ 已禁用!") : 自定义字符串("   Dead Using Ability2 ♂ Is Banned!"));
				开始强制设置玩家位置(事件玩家, 事件玩家, 假);
				等待直到 (!正在使用技能 2(事件玩家), 真);
				等待(假, 无视条件);
				停止强制设置玩家位置(事件玩家);
			End;
			传送(事件玩家, 最后(全局.A[事件玩家.checkpoint_current]));
			"After teleport incase stopForcingPosition launches the player"
			施加推力(事件玩家, -1 * 速率(事件玩家), 1, 至地图, 取消相反运动XYZ);
			"old: disallow jump > 0.1 sec wait > allow jump, this method bugs with ult check disabling ultimate for some reason\nif eventPlayer.ban_dead or eventPlayer.ban_emote and eventPlayer.isHoldingButton(Button.JUMP):Reset Hop"
			设置状态(事件玩家, 空, 定身, 0.096);
		End;
		调用子程序(ResetAbilities);
		调用子程序(AddonCustomLoadAndReset);
	}
}

规则("Parkour | SUB Start Game")
{
	事件
	{
		子程序;
		StartGame;
	}

	动作
	{
		事件玩家.checkpoint_practice = 空;
		事件玩家.toggle_practice = 假;
		事件玩家.toggle_invincible = 假;
		事件玩家.toggle_spectate = 假;
		事件玩家.checkpoint_moved = 真;
		If(数量(全局.A));
			"load saved progres"
			If(数组包含(全局.SaveName, 字符串分割(首个(事件玩家), 空数组)));
				全局.SaveEnt[数组值的索引(全局.SaveName, 字符串分割(首个(事件玩家), 空数组))] = 事件玩家;
				事件玩家.checkpoint_current = 全局.SaveCp[数组值的索引(全局.SaveEnt, 事件玩家)];
				事件玩家.timer_normal = 全局.SaveTimer[数组值的索引(全局.SaveEnt, 事件玩家)];
			Else;
				事件玩家.checkpoint_current = 空;
				事件玩家.timer_normal = 空;
				调用子程序(MakeSave);
			End;
			调用子程序(UpdateTitle);
			调用子程序(UpdateCache);
			调用子程序(CheckpointFailReset);
			"FFA"
			等待直到 (游戏正在进行中, 999999995904.000);
			调用子程序(TimerResume);
		End;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Mechanics | Checks ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Mechanic | All | Jump")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在跳跃(事件玩家) == 真;
	}

	动作
	{
		事件玩家.skill_usedBhop = 真;
		If(事件玩家.skill_usedHop);
			小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   小跳") : 自定义字符串("   Bhop"));
		Else;
			事件玩家.skill_usedHop = 真;
	}
}

规则("Mechanic | All | No Jump")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.skill_usedHop == 空;
		在地面上(事件玩家) == 假;
	}

	动作
	{
		事件玩家.skill_usedHop = 真;
	}
}

规则("Mechanic | All | Bhop Reset")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在地面上(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 假;
	}

	动作
	{
		事件玩家.skill_usedBhop = 假;
	}
}

规则("Mechanic | All | Ground Reset")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		在地面上(事件玩家) == 真;
	}

	动作
	{
		"All"
		事件玩家.skill_usedHop = 空;
		事件玩家.skill_countBhops = 空;
	}
}

规则("Mechanic | Climbers | Bhop count for stand ban")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在跳跃(事件玩家) == 真;
		事件玩家.ban_standcreate != 假;
	}

	动作
	{
		事件玩家.skill_countBhops += 真;
		If(事件玩家.skill_countBhops > 1 && !事件玩家.toggle_invincible);
			小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   卡小 × 已禁用!") : 自定义字符串("   Stand CreateBhop × Is Banned!"));
			调用子程序(CheckpointFailReset);
	}
}

规则("Mechanic | Genji | SUB Reset Abilities")
{
	事件
	{
		子程序;
		ResetAbilities;
	}

	动作
	{
		If(事件玩家.toggle_invincible || (事件玩家 == 主机玩家 && 全局.EditorOn));
			设置启用终极技能(事件玩家, 真);
			设置启用技能 1(事件玩家, 真);
			设置启用技能 2(事件玩家, 真);
			设置辅助攻击模式启用(事件玩家, 真);
		Else;
			设置启用终极技能(事件玩家, 事件玩家.cache_startUlt);
			设置启用技能 1(事件玩家, 事件玩家.cache_startAbility1);
			设置启用技能 2(事件玩家, 事件玩家.cache_startAbility2);
			设置技能冷却(事件玩家, 按钮(技能1), 0);
			设置技能冷却(事件玩家, 按钮(技能2), 0);
			设置技能冷却(事件玩家, 按钮(辅助攻击模式), 0);
		End;
		设置终极技能充能(事件玩家, 100);
	}
}

规则("Mechanic | Genji | Ability 1")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用技能 1(事件玩家) == 真;
	}

	动作
	{
		"Hazard Ability 1 Reset Wall Climb"
		If(事件玩家.toggle_invincible || (全局.EditorOn && 事件玩家 == 主机玩家) || !事件玩家.checkpoint_notLast);
			设置启用技能 1(事件玩家, 真);
		"$$ Doomfist & Vendetta Unlimit lvl"
		Else If(数组包含(全局.UnlimitAbilities, 事件玩家.checkpoint_current) && 所用英雄(事件玩家) == 英雄(斩仇));
		Else;
			设置启用技能 1(事件玩家, 假);
			等待直到 (!正在使用技能 1(事件玩家), 真);
			If(相距距离(事件玩家, 最后(全局.A[事件玩家.checkpoint_current])) <= 1.8);
				调用子程序(ResetAbilities);
	}
}

规则("Mechanic | Genji | Ultimate")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Total Duration: 218 ticks, 3.488s\nCasting: 76 ticks, 1.216s\nBlade: 125 ticks, 2s\nRecovery: 17 ticks, 0.272s\nSwing Duration: 38 ticks, 0.608s"
		正在使用终极技能(事件玩家) == 真;
	}

	动作
	{
		If(事件玩家.toggle_invincible || (全局.EditorOn && 事件玩家 == 主机玩家) || !事件玩家.checkpoint_notLast);
			设置启用终极技能(事件玩家, 真);
			设置终极技能充能(事件玩家, 100);
			等待(3.488, 当为“假”时中止);
			如条件为“真”则循环;
		Else;
			等待直到 (!正在使用终极技能(事件玩家), 1.824);
			"Disallow primary fire because of slash exploit"
			禁用按钮(事件玩家, 按钮(主要攻击模式));
			等待直到 (!正在使用终极技能(事件玩家), 1.664);
			可用按钮(事件玩家, 按钮(主要攻击模式));
			If(相距距离(事件玩家, 最后(全局.A[事件玩家.checkpoint_current])) <= 1.8);
				调用子程序(ResetAbilities);
	}
}

规则("Mechanic | Vendetta | Soaring Slice")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		斩仇;
	}

	条件
	{
		正在使用技能 2(事件玩家) == 真;
	}

	动作
	{
		等待直到 (!正在使用技能 2(事件玩家), 2);
		If(事件玩家.toggle_invincible || (全局.EditorOn && 事件玩家 == 主机玩家) || !事件玩家.checkpoint_notLast);
			设置启用技能 2(事件玩家, 真);
		"$$ Vendetta Unlimit lvl"
		Else If(数组包含(全局.UnlimitAbilities, 事件玩家.checkpoint_current));
		Else;
			设置启用技能 2(事件玩家, 假);
	}
}

规则("Mechanic | Set Abilitys of Vendetta  0 Cooldown")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(事件玩家.toggle_invincible || (全局.EditorOn && 事件玩家 == 主机玩家) || !事件玩家.checkpoint_notLast) == 真;
		技能冷却时间(事件玩家, 按钮(技能1)) + 技能冷却时间(事件玩家, 按钮(技能2)) + 技能冷却时间(事件玩家, 按钮(辅助攻击模式)) + 技能冷却时间(事件玩家, 按钮(跳跃)) > 0.200;
	}

	动作
	{
		If(所用英雄(事件玩家) == 英雄(斩仇));
			设置技能冷却(事件玩家, 按钮(技能1), 0);
			设置技能冷却(事件玩家, 按钮(技能2), 0);
		End;
		等待(0.048, 无视条件);
		如条件为“真”则循环;
	}
}

规则("Mechanic | Ban / Cancle Ability 1 of Vendetta")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		// 事件玩家.toggle_invincible != 真;
		// 事件玩家.checkpoint_notLast == 真;
		正在使用技能 2(事件玩家) != 真;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		根据条件跳过(事件玩家.toggle_invincible || !事件玩家.checkpoint_notLast, 真);
		设置启用技能 1(事件玩家, 假);
		等待直到(按钮被按下(事件玩家, 按钮(辅助攻击模式)), 真);
		根据条件中止(!按钮被按下(事件玩家, 按钮(辅助攻击模式)));
		取消主要动作(事件玩家);
	}
}

规则("Mechanic | Vendetta | Cancel Ultimate")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		正在使用终极技能(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		取消主要动作(事件玩家);
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Editor ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Editor | Export Map")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		按钮被按下(主机玩家, 按钮(近身攻击)) == 真;
		按钮被按下(主机玩家, 按钮(互动)) == 真;
		按钮被按下(主机玩家, 按钮(装填)) == 真;
	}

	动作
	{
		"@Condition hostPlayer.editor_lock == false # !!! don't lock. always be sure data can be exported incase of a perma lock situation"
		等待(真, 当为“假”时中止);
		"doesnt matter thats its in pasta's because it wil be fixed on spawning"
		主机玩家.editor_lock = 真;
		主机玩家.editor_saveCache = 数组(全局.TimeRemaining, 全局.ColorConfig);
		全局.TimeRemaining = 空;
		全局.ColorConfig = 空;
		全局.EditorOn = 空;
		全局.K = 空;
		全局.NANBA = 空;
		全局.TQ2 = 空;
		"Hero Setting"
		全局.SaveName = 空;
		全局.SaveCp = 空;
		全局.SaveTimer = 空;
		全局.SaveEnt = 空;
		"SavePauseTime = null\nSavePauseEnabled = null"
		全局.SaveElapsed = 空;
		全局.CompMode = 空;
		"LeaderBoardFull = null\nLeaderBoardHuds = null"
		全局.PortalOn = 空;
		全局.TitleData = 空;
		全局.CpHudText = 空;
		全局.CpHudCp = 空;
		全局.HintText = 空;
		全局.HintCp = 空;
		全局.CpIwtText = 空;
		全局.CpIwtCp = 空;
		全局.CpIwtPos = 空;
		全局.CpIwtColor = 空;
		全局.PortalNames = 空;
		全局.PortalLoc = 空;
		全局.PortalDest = 空;
		全局.PortalEffects = 空;
		If(全局.Name == 自定义字符串("name here - 作者"));
			全局.Name = 自定义字符串("{0}", 主机玩家);
		End;
		全局.Cachedcredits = 数组(全局.Name, 全局.Code);
		全局.Name = 空;
		全局.Code = 空;
		创建HUD文本(主机玩家, 自定义字符串("­"), 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串(
			"   0. 清理无用数据:\n (此窗口打开时将自动完成)\n\n   1. 复制数据:\n Esc → 打开地图工坊查看器 → 右下角'变量目标'改为全局\n 点击窗口下方图标 (X) 复制作图数据\n\n   2. 录入数据:\n Esc → 打开地图工坊编辑器{0}",
			自定义字符串(
			" → 规则第(2/2)页 → 展开规则'数据录入 <---- 在这输入'\n 点击'动作'一栏右侧橙色粘贴图标 录入数据\n\n   3. 地图工坊设置:\n ESC → 显示大厅 → 设置 → 地图工坊设置→\n 拉至底部 关闭'作图模式'\n 选择地图难度\n{0}",
			自定义字符串(
			"\n   4. 创建初始地图代码:\n Esc → 显示大厅 → 设置 → 分享代码 →\n 创建新的代码 → 复制并记下代码\n\n   5. 添加作者信息:\n Esc → 打开地图工坊编辑器 → 规则第(2/2)页 → 展开规则'Credits Here {0}",
			自定义字符串("- 作者名字'\n 修改自定义字符串文本框中的内容\n\n   6. 更新地图及作者信息:\n Esc → 显示大厅 → 设置 → 共享代码 →\n 上传至现有代码 → 粘贴步骤4中获得的代码")))) : 自定义字符串(
			"   0. Clear Extra Data:\n Already Done Upon Opening This Window\n\n   1. Copy Data:\n Open Workshop Inspector → Set Variable Targ{0}",
			自定义字符串(
			"et To Global\n Click The [X]\n\n   2. Insert Data:\n Paste The Data Into Rule Named 'Map Data <---- Insert Here'\n\n   3. Workshop {0}",
			自定义字符串(
			"Settings:\n Esc → Show Lobby → Settings → Workshop Settings →\n Toggle 'Editor Mode' Off\n Select Display Difficulty\n\n   4. Crea{0}",
			自定义字符串(
			"te Initial Sharecode:\n Esc → Show Lobby → Settings → Share Code →\n Create New Code → Copy Code\n\n   5. Add Credits:\n Enter You{0}",
			自定义字符串(
			"r Name & Map Code In The 'Credits Here' Rule\n\n   6. Update For Credits:\n Esc → Show Lobby → Settings → Share Code →\n Upload T{0}",
			自定义字符串("o Existing Code → Paste The Code You Created In Step 4")))))), 顶部, -185, 空, 空, 颜色(灰绿色), 字符串, 默认可见度);
		主机玩家.editor_saveCache[2] = 上一个文本ID;
		启用查看器录制;
		禁用查看器录制;
		全局.EditorOn = 真;
		全局.TimeRemaining = 首个(主机玩家.editor_saveCache);
		全局.ColorConfig = 主机玩家.editor_saveCache[真];
		创建HUD文本(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("    > 按互动键关闭当前窗口 <    ") : 自定义字符串(
			"    > Press Interact To Close This Window <    "), 空, 空, 顶部, -183, 颜色(灰绿色), 空, 空, 字符串, 默认可见度);
		主机玩家.editor_saveCache[假] = 上一个文本ID;
		等待直到 (!按钮被按下(主机玩家, 按钮(互动)), 999999995904.000);
		等待直到 (按钮被按下(主机玩家, 按钮(互动)), 999999995904.000);
		"Close Window"
		消除HUD文本(首个(主机玩家.editor_saveCache));
		"Instructions"
		消除HUD文本(最后(主机玩家.editor_saveCache));
		主机玩家.editor_saveCache = 空;
		主机玩家.editor_lock = 假;
	}
}

规则("Editor | Hud & Effects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待(1.024, 无视条件);
		"waitUntil(entityExists(getAllPlayers()), Math.INFINITY)  # cant be condition because host player can leaves, removing the rule fx\nwait()"
		If(全局.EditorOn);
			创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0}+{1}+{2} | 重新开始", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(技能2)), 输入绑定字符串(
				按钮(互动))) : 自定义字符串("{0}+{1}+{2} | Restart", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(互动))), 右边, -156, 空, 空,
				全局.ColorConfig[5], 可见和字符串, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide ? 主机玩家 : 空, 空, 空, 字符串("噢") == 自定义字符串("噢") ? (全局.EditorMoveItem ? 自定义字符串(
				"方向键 | 移动实体 \n{0} | 向上移动 \n{1} | 向下移动 \n{2} (长按) | 快速移动", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(跳跃))) : 数组(自定义字符串(
				"{0} + {1} | 新建检查点\n{0} + {2} | 删除选中的检查点", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(辅助攻击模式))), 自定义字符串(
				"{0} + {1} | 新建击杀球\n{0} + {1} (长按) | 在准心位置新建", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(主要攻击模式))), 自定义字符串(
				"{0} + {1} | 新建弹球\n{0} + {1} (长按) | 在准心位置新建", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(主要攻击模式))), 自定义字符串(""), 自定义字符串(
				"{0} + {1} | 新建传送门\n{0} + {1} (长按) | 在准心位置新建", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(主要攻击模式))))[主机玩家.editor_modeSelect]) : (
				全局.EditorMoveItem ? 自定义字符串("Walk | Move Selected\n{0} | Move Up\n{1} | Move Down\n{2} (Hold) | Move Faster", 输入绑定字符串(按钮(技能2)),
				输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(跳跃))) : 数组(自定义字符串("{0} + {1} | Create New\n{0} + {2} | Delete Selected", 输入绑定字符串(按钮(互动)),
				输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(辅助攻击模式))), 自定义字符串("{0} + {1} | Create New\n{0} + {1} (Hold)| Raycast New", 输入绑定字符串(按钮(互动)),
				输入绑定字符串(按钮(主要攻击模式))), 自定义字符串("{0} + {1} | Create New\n{0} + {1} (Hold)| Raycast New", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(主要攻击模式))),
				自定义字符串("{0} + {1} | Multi-Climb\n{0} + {2} | Createbhop", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(辅助攻击模式))), 自定义字符串(
				"{0} + {1} | Create New\n{0} + {1} (Hold)| Raycast New", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(主要攻击模式))))[主机玩家.editor_modeSelect]), 右边,
				-148, 空, 空, 颜色(黄色), 可见和字符串, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide && !全局.EditorMoveItem ? 主机玩家 : 空, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 数组(空数组, 自定义字符串("{0} + {1} | 删除选中的击杀球",
				输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(辅助攻击模式))), 自定义字符串("{0} + {1} | 删除选中的弹球", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(辅助攻击模式))), 空数组, 自定义字符串(
				"{0} + {1} | 删除选中的传送门", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(辅助攻击模式))))[主机玩家.editor_modeSelect] : 数组(空数组, 自定义字符串(
				"{0} + {1} | Delete Selected", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(辅助攻击模式))), 自定义字符串("{0} + {1} | Delete Selected", 输入绑定字符串(按钮(互动)),
				输入绑定字符串(按钮(辅助攻击模式))), 空数组, 自定义字符串("{0} + {1} | Delete Selected", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(辅助攻击模式))))
				[主机玩家.editor_modeSelect], 右边, -147, 空, 空, 颜色(黄色), 可见和字符串, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide ? 主机玩家 : 空, 空, 空, 字符串("噢") == 自定义字符串("噢") ? (全局.EditorMoveItem ? 自定义字符串(
				"{0} | 放置实体{1} | Cancel Placement\n", 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(辅助攻击模式))) : 数组(自定义字符串(
				"{0} + {1} | 移除/新建传送点\n{0} + {2} | 检查点碰撞模型\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填)), 输入绑定字符串(按钮(技能1))), 自定义字符串(
				"{0} + {1} | 选择上一个击杀球\n{0} + {2} | 选择下一个击杀球\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(跳跃))), 自定义字符串(
				"{0} + {1} | 选择上一个弹球\n{0} + {2} | 选择下一个弹球\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(跳跃))), 自定义字符串(""), 自定义字符串(
				"{0} + {1} | 选择下一个传送门\n{0} + {2} | 选择上一个传送门\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))))[主机玩家.editor_modeSelect])
				: (全局.EditorMoveItem ? 自定义字符串("{0} | Confirm Placement\n{1} | Cancel Placement", 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(辅助攻击模式)))
				: 数组(自定义字符串("{0} + {1} | Remove/Add Teleport\n{0} + {2} | Toggle Hitbox\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(装填)), 输入绑定字符串(按钮(
				技能1))), 自定义字符串("{0} + {1} | Select Previous\n{0} + {2} | Select Next\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(跳跃))),
				自定义字符串("{0} + {1} | Select Previous\n{0} + {2} | Select Next\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(跳跃))), 自定义字符串(
				"{0} + {1} | Wallclimb\n{0} + {2} | Save Double", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(跳跃))), 自定义字符串(
				"{0} + {1} | Select Next\n{0} + {2} | Select Previous\n", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))))
				[主机玩家.editor_modeSelect]), 右边, -146, 空, 空, 颜色(黄色), 可见和字符串, 默认可见度);

			创建HUD文本(主机玩家.toggle_guide && !全局.EditorMoveItem ? 主机玩家 : 空, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 
			// "lang cn"
			数组(自定义字符串("{0} (长按) | 移动检查点", 输入绑定字符串(
				按钮(技能2))), 自定义字符串("{0} + {1} | 增大击杀球\n{0} + {2} | 缩小击杀球", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))), 自定义字符串(
				"{0} + {1} | 增加弹球弹力\n{0} + {2} | 减少弹球弹力", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))), 
				自定义字符串(
				"{0} + {1} | 死亡E", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(终极技能))), 自定义字符串(
				"{0} + {1} | 移动选中的实体\n{0} + {2} | 应用到当前/所有关卡(开关)", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(跳跃))))
				[主机玩家.editor_modeSelect] : 
			// "lang en"
			数组(自定义字符串("{0} (Hold) | Move", 输入绑定字符串(按钮(技能2))), 自定义字符串(
				"{0} + {1} | Increase Size\n{0} + {2} | Decrease Size", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))), 自定义字符串(
				"{0} + {1} | Increase Strength\n{0} + {2} | Decrease Strength", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))), 自定义字符串(
				"{0} + {1} | Death Ability2", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(终极技能))), 自定义字符串(
				"{0} + {1} | Move\n{0} + {2} | Cp/Map (Toggle)", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(跳跃))))
				[主机玩家.editor_modeSelect], 右边, -145, 空, 空, 颜色(黄色), 可见和字符串, 默认可见度);

			创建HUD文本(主机玩家.toggle_guide && !全局.EditorMoveItem ? 主机玩家 : 空, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 
			// "lang cn"
			数组(空数组, 自定义字符串("{0} + {1} | 移动选中的实体",
				输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(主要攻击模式))), 自定义字符串("{0} + {1} | 移动选中的实体", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(主要攻击模式))), 自定义字符串(
				"{0} + {1} | 留小跳进点\n{0} + {2} | 卡小跳", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))), 空数组)
				[主机玩家.editor_modeSelect] : 
			// "lang en"
			数组(空数组, 自定义字符串("{0} + {1} | Move", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(主要攻击模式))), 自定义字符串("{0} + {1} | Move", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(
				按钮(主要攻击模式))), 自定义字符串("{0} + {1} | Require Bhop\n{0} + {2} | Stand Create", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(跳跃)), 输入绑定字符串(按钮(蹲下))),
				空数组)[主机玩家.editor_modeSelect], 右边, -144, 空, 空, 颜色(黄色), 可见和字符串, 默认可见度);

			创建HUD文本(主机玩家.toggle_guide ? 主机玩家 : 空, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串(" \n{0} + {1} | 下一关", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(
				主要攻击模式))) : 自定义字符串(" \n{0} + {1} | Next Checkpoint", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(主要攻击模式))), 右边, -150, 空, 空,
				主机玩家.toggle_guide ? 颜色(绿色) : 颜色(橙色), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide ? 主机玩家 : 空, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} | 上一关\n{2} (长按) | 飞行\n", 输入绑定字符串(按钮(蹲下)),
				输入绑定字符串(按钮(辅助攻击模式)), 输入绑定字符串(按钮(技能1))) : 自定义字符串("{0} + {1} | Prev Checkpoint\n{2} (hold)| Fly\n", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(
				辅助攻击模式)), 输入绑定字符串(按钮(技能1))), 右边, -149, 空, 空, 主机玩家.toggle_guide ? 颜色(绿色) : 颜色(橙色), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide ? 主机玩家 : 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("保存地图长按 {0} + {1} + {2}", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(
				近身攻击)), 自定义字符串(
				"{0} 后按弹出窗口的提示进行操作                                                                                                ", 输入绑定字符串(
				按钮(装填)))) : 自定义字符串("To Save Map, Hold {0} + {1} + {2}", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(近身攻击)), 自定义字符串(
				"{0} Then Follow Instructions                                                                                                ",
				输入绑定字符串(按钮(装填)))), 空, 左边, -197, 空, 颜色(黄色), 空, 可见和字符串, 默认可见度);
			创建HUD文本(本地玩家.editor_saveCache ? 空 : 本地玩家, 字符串("噢") == 自定义字符串("噢") ? (按钮被按下(主机玩家, 按钮(近身攻击)) ? 自定义字符串("{0} 检查点模式\n{1} 击杀球模式\n{2}",
				主机玩家.editor_modeSelect ? 自定义字符串("     ") : 图标字符串(箭头：向右), 主机玩家.editor_modeSelect == 1 ? 图标字符串(箭头：向右) : 自定义字符串("     "), 自定义字符串(
				"{0} 弹球模式\n{1} 封禁(单关)\n{2} 自定义传送门 ", 主机玩家.editor_modeSelect == 2 ? 图标字符串(箭头：向右) : 自定义字符串("     "),
				主机玩家.editor_modeSelect == 3 ? 图标字符串(箭头：向右) : 自定义字符串("     "), 主机玩家.editor_modeSelect == 4 ? 图标字符串(箭头：向右) : 自定义字符串("     ")))
				: (本地玩家 == 主机玩家 ? 自定义字符串(" {0} {1} ", 数组(图标字符串(旗帜), 图标字符串(骷髅), 图标字符串(满月), 图标字符串(停止), 图标字符串(螺旋))[主机玩家.editor_modeSelect], 字符串分割(
				自定义字符串("检查点模式0击杀球模式0弹球模式0封禁(单关)0自定义传送门"), 首个(空))[主机玩家.editor_modeSelect]) : 自定义字符串(" {0} 斩仇 编辑者 {0} ", 图标字符串(箭矢)))) : (按钮被按下(
				主机玩家, 按钮(近身攻击)) ? 自定义字符串("{0} Checkpoints\n{1} Boundary Spheres\n{2}", 主机玩家.editor_modeSelect ? 自定义字符串("     ") : 图标字符串(箭头：向右),
				主机玩家.editor_modeSelect == 1 ? 图标字符串(箭头：向右) : 自定义字符串("     "), 自定义字符串("{0} Function Orbs\n{1} Skill Bans\n{2} Portals",
				主机玩家.editor_modeSelect == 2 ? 图标字符串(箭头：向右) : 自定义字符串("     "), 主机玩家.editor_modeSelect == 3 ? 图标字符串(箭头：向右) : 自定义字符串("     "),
				主机玩家.editor_modeSelect == 4 ? 图标字符串(箭头：向右) : 自定义字符串("     "))) : (本地玩家 == 主机玩家 ? 自定义字符串(" {0} {1} ", 数组(图标字符串(旗帜), 图标字符串(骷髅),
				图标字符串(满月), 图标字符串(停止), 图标字符串(螺旋))[主机玩家.editor_modeSelect], 字符串分割(自定义字符串(
				"Checkpoints0Boundary Spheres0Function Orbs0Skill Bans0Portals"), 首个(空))[主机玩家.editor_modeSelect]) : 自定义字符串(
				" {0} Genji Editor {0} ", 图标字符串(箭矢)))), 空, 空, 顶部, -174, 颜色(蓝色), 空, 空, 可见和字符串, 默认可见度);
			创建HUD文本(首个(真), 空, 字符串("噢") == 自定义字符串("噢") ? (本地玩家 == 主机玩家 ? 自定义字符串("{0} + 射击 | 切换作图模式", 输入绑定字符串(按钮(近身攻击))) : 自定义字符串("房主/编辑者 {0}",
				主机玩家)) : (本地玩家 == 主机玩家 ? 自定义字符串("{0} + Shoot | Change Mode", 输入绑定字符串(按钮(近身攻击))) : 自定义字符串("Current Host/Editor: {0}", 主机玩家)), 空,
				顶部, -175, 空, 本地玩家.editor_lock ? 颜色(灰色) : 颜色(白色), 空, 可见，字符串和颜色, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide && (!主机玩家.editor_modeSelect || (主机玩家.editor_modeSelect == 2 && 数量(主机玩家.editor_bounceIndex))) ? 主机玩家 : 空,
				空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} | {2}", 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(主要攻击模式)), 自定义字符串(
				"{0} {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("弹球给终极技能") : 自定义字符串("检查点给终极技能"), 技能图标字符串(所用英雄(本地玩家), 按钮(终极技能)),
				主机玩家.editor_modeSelect == 2 ? 全局.TQ5[全局.EditSelected] : 数组包含(全局.Dao, 主机玩家.checkpoint_current))) : 自定义字符串("{0} + {1} | {2}",
				输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(主要攻击模式)), 自定义字符串(
				"{0} Give Ult {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("Orb") : 自定义字符串("Level"), 技能图标字符串(所用英雄(本地玩家), 按钮(终极技能)),
				主机玩家.editor_modeSelect == 2 ? 全局.TQ5[全局.EditSelected] : 数组包含(全局.Dao, 主机玩家.checkpoint_current))), 左边, -189, 空, 空,
				全局.TQ5[全局.EditSelected] && 主机玩家.editor_modeSelect == 2 ? 颜色(绿色) : (数组包含(全局.Dao, 主机玩家.checkpoint_current)
				&& !主机玩家.editor_modeSelect ? 颜色(绿色) : 颜色(橙色)), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide && (!主机玩家.editor_modeSelect || (主机玩家.editor_modeSelect == 2 && 数量(主机玩家.editor_bounceIndex))) ? 主机玩家 : 空,
				空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} | {2}", 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(辅助攻击模式)), 自定义字符串(
				"{0} {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("弹球给技能1") : 自定义字符串("检查点给技能1"), 技能图标字符串(所用英雄(本地玩家), 按钮(技能1)),
				主机玩家.editor_modeSelect == 2 ? 全局.TQ6[全局.EditSelected] : 数组包含(全局.SHIFT, 主机玩家.checkpoint_current))) : 自定义字符串("{0} + {1} | {2}",
				输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(辅助攻击模式)), 自定义字符串(
				"{0} Give Ability 1 {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("Orb") : 自定义字符串("Level"), 技能图标字符串(所用英雄(本地玩家), 按钮(技能1)),
				主机玩家.editor_modeSelect == 2 ? 全局.TQ6[全局.EditSelected] : 数组包含(全局.SHIFT, 主机玩家.checkpoint_current))), 左边, -188, 空, 空,
				全局.TQ6[全局.EditSelected] && 主机玩家.editor_modeSelect == 2 ? 颜色(绿色) : (数组包含(全局.SHIFT, 主机玩家.checkpoint_current)
				&& !主机玩家.editor_modeSelect ? 颜色(绿色) : 颜色(橙色)), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide && (!主机玩家.editor_modeSelect || (主机玩家.editor_modeSelect == 2 && 数量(主机玩家.editor_bounceIndex))) ? 主机玩家 : 空,
				空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} | {2}", 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(技能2)), 自定义字符串(
				"{0} {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("弹球给技能2") : 自定义字符串("检查点给技能2"), 技能图标字符串(所用英雄(本地玩家), 按钮(技能2)),
				主机玩家.editor_modeSelect == 2 ? 全局.TQ7[全局.EditSelected] : 数组包含(全局.Ability2, 主机玩家.checkpoint_current))) : 自定义字符串(
				"{0} + {1} | {2}", 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(技能2)), 自定义字符串(
				"{0} Give Ability 2 {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("Orb") : 自定义字符串("Level"), 技能图标字符串(所用英雄(本地玩家), 按钮(技能2)),
				主机玩家.editor_modeSelect == 2 ? 全局.TQ7[全局.EditSelected] : 数组包含(全局.Ability2, 主机玩家.checkpoint_current))), 左边, -188, 空, 空,
				全局.TQ7[全局.EditSelected] && 主机玩家.editor_modeSelect == 2 ? 颜色(绿色) : (数组包含(全局.Ability2, 主机玩家.checkpoint_current)
				&& !主机玩家.editor_modeSelect ? 颜色(绿色) : 颜色(橙色)), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide && (!主机玩家.editor_modeSelect || (主机玩家.editor_modeSelect == 2 && 数量(主机玩家.editor_bounceIndex))) ? 主机玩家 : 空,
				空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} | {2}", 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(互动)), 自定义字符串(
				"{0} {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("收集球(进点前必须集齐)") : 自定义字符串("无限技能关卡"), 主机玩家.editor_modeSelect ? 图标字符串(星形) : 英雄图标字符串(英雄(斩仇)), 主机玩家.editor_modeSelect == 2 ? 全局.BounceToggleLock[全局.EditSelected] : 数组包含(全局.UnlimitAbilities,
				主机玩家.checkpoint_current))) : 自定义字符串("{0} + {1} | {2}", 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(互动)), 自定义字符串(
				"{0} {1} | {2}                                                                                                ",
				主机玩家.editor_modeSelect ? 自定义字符串("Unlocks Checkpoint") : 自定义字符串("Unlimit Abilities"), 主机玩家.editor_modeSelect ? 图标字符串(星形)
				: 英雄图标字符串(英雄(斩仇)), 主机玩家.editor_modeSelect == 2 ? 全局.BounceToggleLock[全局.EditSelected] : 数组包含(
				全局.UnlimitAbilities, 主机玩家.checkpoint_current))), 左边, -187, 空, 空,
				全局.BounceToggleLock[全局.EditSelected] && 主机玩家.editor_modeSelect == 2 ? 颜色(绿色) : (数组包含(全局.UnlimitAbilities,
				主机玩家.checkpoint_current) && !主机玩家.editor_modeSelect ? 颜色(绿色) : 颜色(橙色)), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(主机玩家.toggle_guide ? 主机玩家 : 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("球体/传送门上限: {0}/193 ", 数量(全局.TQ) + 数量(全局.H) + 数量(
				全局.CustomPortalStart)) : 自定义字符串("Orb/Portal Limit: {0}/193 ", 数量(全局.TQ) + 数量(全局.H) + 数量(全局.CustomPortalStart)), 空, 自定义字符串(
				"                                                                                                                                "),
				左边, -191, 颜色(蓝色), 空, 空, 可见和字符串, 默认可见度);
			"display selected cc/orb info"
			创建HUD文本(主机玩家.toggle_guide ? 主机玩家 : 空, 字符串("噢") == 自定义字符串("噢") ? (!主机玩家.editor_modeSelect && 数量(全局.A) ? 自定义字符串(
				"\n 选中的检查点 \n 矢量: {0}{1} \n", 全局.A[主机玩家.checkpoint_current], 数量(全局.A[主机玩家.checkpoint_current]) < 2 ? 空数组 : 自定义字符串(
				"\n 传送点: {0}", 全局.A[主机玩家.checkpoint_current][真])) : (主机玩家.editor_modeSelect == 1 && 数量(主机玩家.editor_killIndex) ? 自定义字符串(
				"\n 选中的击杀球\n 矢量: {0}\n 半径: {1}\n  + 進不去\n  - 出不來\n", 全局.H[全局.EditSelected], 全局.I[全局.EditSelected]) : (
				主机玩家.editor_modeSelect == 2 && 数量(主机玩家.editor_bounceIndex) ? 自定义字符串("\n 选中的弹球\n 矢量: {0}\n 弹力: {1}\n 序号: {2}\n",
				全局.TQ[全局.EditSelected], 全局.EditMode[全局.EditSelected], 全局.EditSelected) : (主机玩家.editor_modeSelect == 3 ? 
					
				自定义字符串(
				"\n 封禁(单关)\n――――――――――――\n {0} 卡小跳 ×\n {1} 留小跳进点 ↓\n{2}\n――――――――――――\n", 数组包含(全局.BanStand, 主机玩家.checkpoint_current) ? 自定义字符串("√")
				: 空数组, 数组包含(全局.BanBhop, 主机玩家.checkpoint_current) ? 自定义字符串("√") : 空数组,自定义字符串(" {0} 死亡E ♂",数组包含(全局.BanDead, 主机玩家.checkpoint_current) ? 自定义字符串("√") : 空数组))
				
				: (主机玩家.editor_modeSelect == 4 && 数组包含(数组(
				主机玩家.checkpoint_current, -1), 全局.CustomPortalCP[全局.EditSelected]) && 数量(全局.CustomPortalCP) ? 自定义字符串(
				"\n 入口矢量: {0}\n 出口矢量: {1}\n 应用关卡: {2}\n", 全局.CustomPortalStart[全局.EditSelected], 全局.CustomPortalEndpoint[全局.EditSelected],
				全局.CustomPortalCP[全局.EditSelected] < 空 ? 自定义字符串("所有") : 主机玩家.checkpoint_current) : 自定义字符串("\n   当前无数据选中   \n")))))) : (
				!主机玩家.editor_modeSelect && 数量(全局.A) ? 自定义字符串("\n Selected Checkpoint\n Vector: {0}{1} \n", 全局.A[主机玩家.checkpoint_current], 数量(
				全局.A[主机玩家.checkpoint_current]) < 2 ? 空数组 : 自定义字符串("\n Teleport: {0}", 全局.A[主机玩家.checkpoint_current][真])) : (
				主机玩家.editor_modeSelect == 1 && 数量(主机玩家.editor_killIndex) ? 自定义字符串(
				"\n Selected Boundary Sphere\n Vector: {0}\n Radius: {1}\n  + Keep Out\n  - Stay In\n", 全局.H[全局.EditSelected],
				全局.I[全局.EditSelected]) : (主机玩家.editor_modeSelect == 2 && 数量(主机玩家.editor_bounceIndex) ? 自定义字符串(
				"\n Selected Bounce Orb\n Vector: {0}\n Strength: {1} \n ID: {2}\n", 全局.TQ[全局.EditSelected], 全局.EditMode[全局.EditSelected],
				全局.EditSelected) : (主机玩家.editor_modeSelect == 3 ? 

				自定义字符串(
				"\n 封禁(单关)\n――――――――――――\n {0} 卡小跳 ×\n {1} 留小跳进点 ↓\n{2}\n――――――――――――\n", 数组包含(全局.BanStand, 主机玩家.checkpoint_current) ? 自定义字符串("√")
				: 空数组, 数组包含(全局.BanBhop, 主机玩家.checkpoint_current) ? 自定义字符串("√") : 空数组,自定义字符串(" {0} 死亡E ♂",数组包含(全局.BanDead, 主机玩家.checkpoint_current) ? 自定义字符串("√") : 空数组))

				
				: (主机玩家.editor_modeSelect == 4 && 数组包含(数组(主机玩家.checkpoint_current, -1), 全局.CustomPortalCP[全局.EditSelected]) && 数量(
				全局.CustomPortalCP) ? 自定义字符串("\n Start: {0} \n End: {1} \n CP: {2} \n", 全局.CustomPortalStart[全局.EditSelected],
				全局.CustomPortalEndpoint[全局.EditSelected], 全局.CustomPortalCP[全局.EditSelected] < 空 ? 自定义字符串("All") : 主机玩家.checkpoint_current)
				: 自定义字符串("\n   No Data Selected   \n")))))), 空, 自定义字符串(
				"                                                                                                                                "),
				左边, -190, 颜色(白色), 空, 颜色(橙色), 可见和字符串, 默认可见度);
			"effects =========================================================================================================================================================================="
			创建地图文本(数量(全局.EditSelectIdArray) ? 真 : 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("选中的实体") : 自定义字符串("Selected"),
				主机玩家.editor_modeSelect == 1 ? 全局.H[全局.EditSelected] : (主机玩家.editor_modeSelect == 2 ? 全局.TQ[全局.EditSelected] : (
				主机玩家.editor_modeSelect == 4 ? 全局.CustomPortalStart[全局.EditSelected] : 空)), 1.200, 不要截取, 可见和位置, 颜色(橙色), 默认可见度);
			创建图标(数量(全局.EditSelectIdArray) ? 真 : 空, 主机玩家.editor_modeSelect == 1 ? 全局.H[全局.EditSelected] : (
				主机玩家.editor_modeSelect == 2 ? 全局.TQ[全局.EditSelected] : (
				主机玩家.editor_modeSelect == 4 ? 全局.CustomPortalStart[全局.EditSelected] : 空)), 箭头：向下, 可见和位置, 颜色(白色), 真);
			"Purple sphere for teleport location"
			创建效果(数量(全局.A[主机玩家.checkpoint_current]) > 1 && !主机玩家.editor_modeSelect ? 主机玩家 : 空, 球体, 颜色(亮紫色),
				全局.A[主机玩家.checkpoint_current][真] - 0.100 * 上, 0.200, 可见，位置和半径);
			"Teleport text"
			创建地图文本(数量(全局.A[主机玩家.checkpoint_current]) > 1 && !主机玩家.editor_modeSelect ? 主机玩家 : 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("传送点位置")
				: 自定义字符串("teleporter location"), 全局.A[主机玩家.checkpoint_current][真], 1.600, 不要截取, 可见，位置和字符串, 颜色(天蓝色), 默认可见度);
			"normal cp if teleport"
			创建效果(全局.A[主机玩家.checkpoint_current][真] && !主机玩家.editor_modeSelect ? 主机玩家 : 空, 环, 颜色(橙色), 首个(全局.A[主机玩家.checkpoint_current]), 真,
				可见，位置和半径);
			创建地图文本(全局.A[主机玩家.checkpoint_current][真] && !主机玩家.editor_modeSelect ? 主机玩家 : 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("检查点位置") : 自定义字符串(
				"level location"), 首个(全局.A[主机玩家.checkpoint_current]), 1.600, 不要截取, 可见，位置和字符串, 颜色(天蓝色), 默认可见度);
			"portal fx"
			创建效果(数量(全局.EditSelectIdArray) && 主机玩家.editor_modeSelect == 4 ? 主机玩家 : 空, 火花, 颜色(亮紫色), 全局.CustomPortalEndpoint[全局.EditSelected],
				0.200, 可见，位置和半径);
	}
}

规则("Editor | Toggle Fly & Noclip")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.EditorOn != 假;
		按钮被按下(事件玩家, 按钮(技能1)) == 真;
		事件玩家.editor_fly == 空;
		(全局.EditorMoveItem && 事件玩家 == 主机玩家) == 假;
	}

	动作
	{
		等待直到 (按钮被按下(事件玩家, 按钮(装填)) || !按钮被按下(事件玩家, 按钮(技能1)), 0.700);
		If(按钮被按下(事件玩家, 按钮(装填)) || !按钮被按下(事件玩家, 按钮(技能1)));
			等待(假, 无视条件);
			中止;
		End;
		事件玩家.editor_fly = 所选位置(事件玩家) + 上;
		开始强制设置玩家位置(事件玩家, 事件玩家.editor_fly, 真);
		取消与环境的移动碰撞(事件玩家, 真);
		禁用按钮(事件玩家, 按钮(终极技能));
		等待直到 (!按钮被按下(事件玩家, 按钮(技能1)), 真);
		While(存活(事件玩家) && 事件玩家.editor_fly && !按钮被按下(事件玩家, 按钮(技能1)));
			If(事件玩家 != 主机玩家 || !事件玩家.editor_lock);
				事件玩家.editor_fly += (0.096 + 0.192 * 按钮被按下(事件玩家, 按钮(跳跃)) - 0.048 * 按钮被按下(事件玩家, 按钮(蹲下))) * (面朝方向(事件玩家) * Z方向分量(阈值(事件玩家)) * 矢量(真,
					!按钮被按下(事件玩家, 按钮(技能1)), 真) + 地图矢量(阈值(事件玩家) * 左, 事件玩家, 旋转) + 上 * (按钮被按下(事件玩家, 按钮(技能2)) - 按钮被按下(事件玩家, 按钮(终极技能))));
			Else If(!主机玩家.editor_modeSelect);
				事件玩家.editor_fly += (0.003 + 0.093 * 按钮被按下(事件玩家, 按钮(主要攻击模式))) * (面朝方向(事件玩家) * Z方向分量(阈值(事件玩家)) + 地图矢量(阈值(事件玩家) * 左, 事件玩家, 旋转) + 上 * (
					按钮被按下(事件玩家, 按钮(跳跃)) - 按钮被按下(事件玩家, 按钮(蹲下))));
			End;
			等待(假, 无视条件);
		End;
		可用按钮(事件玩家, 按钮(终极技能));
		开启与环境的移动碰撞(事件玩家);
		事件玩家.editor_fly = 空;
		停止强制设置玩家位置(事件玩家);
		等待(真, 无视条件);
	}
}

规则("Editor | Change Mode")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"@Event eachPlayer\n@Condition eventPlayer == hostPlayer"
		全局.EditorOn != 假;
		主机玩家.editor_lock == 假;
		按钮被按下(主机玩家, 按钮(近身攻击)) == 真;
		按钮被按下(主机玩家, 按钮(主要攻击模式)) != 按钮被按下(主机玩家, 按钮(辅助攻击模式));
	}

	动作
	{
		主机玩家.editor_lock = 真;
		If(按钮被按下(主机玩家, 按钮(主要攻击模式)));
			主机玩家.editor_modeSelect += 4;
		Else;
			主机玩家.editor_modeSelect += 真;
		End;
		主机玩家.editor_modeSelect %= 5;
		调用子程序(EditUpdateSelectedIds);
		全局.EditSelected = 最后(全局.EditSelectIdArray);
		等待(假, 无视条件);
		等待直到 (按钮被按下(主机玩家, 按钮(主要攻击模式)) == 按钮被按下(主机玩家, 按钮(辅助攻击模式)), 0.100);
		主机玩家.editor_lock = 假;
	}
}

规则("Editor | Update Selected Id")
{
	事件
	{
		子程序;
		EditUpdateSelectedIds;
	}

	动作
	{
		If(主机玩家.editor_modeSelect == 1);
			全局.EditSelectIdArray = 映射的数组(全局.killballnumber, 当前数组索引);
			全局.EditSelectIdArray = 已过滤的数组(全局.EditSelectIdArray, 全局.killballnumber[当前数组元素] == 主机玩家.checkpoint_current);
		Else If(主机玩家.editor_modeSelect == 2);
			全局.EditSelectIdArray = 映射的数组(全局.pinballnumber, 当前数组索引);
			全局.EditSelectIdArray = 已过滤的数组(全局.EditSelectIdArray, 全局.pinballnumber[当前数组元素] == 主机玩家.checkpoint_current);
		Else If(主机玩家.editor_modeSelect == 4);
			全局.EditSelectIdArray = 映射的数组(全局.CustomPortalCP, 当前数组索引);
			全局.EditSelectIdArray = 已过滤的数组(全局.EditSelectIdArray,
				全局.CustomPortalCP[当前数组元素] < 空 || 全局.CustomPortalCP[当前数组元素] == 主机玩家.checkpoint_current);
		Else;
			全局.EditSelectIdArray = 空数组;
		End;
	}
}

规则("Editor | Create Cp/Orb")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Required for UpdateCache"
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		主机玩家.editor_lock == 假;
		数组包含(数组(空, 1, 2, 4), 主机玩家.editor_modeSelect) == 真;
		按钮被按下(主机玩家, 按钮(互动)) == 真;
		按钮被按下(主机玩家, 按钮(主要攻击模式)) == 真;
	}

	动作
	{
		主机玩家.editor_lock = 真;
		If(!主机玩家.editor_modeSelect);
			If(数量(全局.A) && 相距距离(主机玩家, 全局.A[主机玩家.checkpoint_current]) <= 1.8);
				小字体信息(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   放置的检查点距离太近") : 自定义字符串("   Cannot Place Checkpoint Too Close."));
			Else;
				"$$"
				If(主机玩家.checkpoint_current >= 数量(全局.A) - 真);
					主机玩家.checkpoint_current = 数量(全局.A) - 真;
				End;
				If(主机玩家.checkpoint_current == 数量(全局.A) - 真);
					修改全局变量(A, 添加至数组, 所选位置(主机玩家));
					主机玩家.checkpoint_current += 真;
				Else;
					修改全局变量(A, 添加至数组, 所选位置(主机玩家));
					全局.A = 映射的数组(全局.A, 当前数组索引 < 主机玩家.checkpoint_current + 真 ? 当前数组元素 : (当前数组索引 == 主机玩家.checkpoint_current + 真 ? 最后(全局.A)
						: 全局.A[当前数组索引 - 真]));
					主机玩家.checkpoint_current += 真;
					全局.killballnumber = 映射的数组(全局.killballnumber, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.pinballnumber = 映射的数组(全局.pinballnumber, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.CustomPortalCP = 映射的数组(全局.CustomPortalCP, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.Dao = 映射的数组(全局.Dao, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.SHIFT = 映射的数组(全局.SHIFT, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.Ability2 = 映射的数组(全局.Ability2, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.UnlimitAbilities = 映射的数组(全局.UnlimitAbilities, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.BanDead = 映射的数组(全局.BanDead, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.BanStand = 映射的数组(全局.BanStand, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
					全局.BanBhop = 映射的数组(全局.BanBhop, 当前数组元素 + (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
				End;
				调用子程序(UpdateCache);
				调用子程序(CheckpointFailReset);
				小字体信息(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   新检查点已创建") : 自定义字符串("   New Checkpoint Created"));
			End;
		Else If(!数量(全局.A));
			小字体信息(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   请先放置检查点") : 自定义字符串("   Make A Checkpoint First"));
		Else If(数量(全局.TQ) + 数量(全局.H) + 数量(全局.CustomPortalStart) >= 193);
			大字体信息(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("当前地图弹球/传送门数量已达上限") : 自定义字符串("Orb/Portal Limit Reached For This Map"));
		Else If(主机玩家.editor_modeSelect == 1);
			修改全局变量(H, 添加至数组, 所选位置(主机玩家));
			修改全局变量(killballnumber, 添加至数组, 主机玩家.checkpoint_current);
			修改全局变量(I, 添加至数组, 5);
			"to create the fx properly"
			调用子程序(EditUpdateSelectedIds);
			全局.EditSelected = 最后(全局.EditSelectIdArray);
			创建效果(已过滤的数组(所有玩家(所有队伍), 当前数组元素.checkpoint_current == 全局.killballnumber[单次赋值(全局.EditSelected)]), 球体, 全局.ColorConfig[14], 全局.H[单次赋值(
				全局.EditSelected)], 绝对值(全局.I[单次赋值(全局.EditSelected)]), 可见，位置和半径);
			修改全局变量(K, 添加至数组, 最后创建的实体);
			大字体信息(首个(真), 自定义字符串("{0} {1}", 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("新击杀球已创建! \n仅生效于检查点") : 自定义字符串(
				"New boundary Sphere Created! \nOnly Valid For This Checkpoint"), 主机玩家.checkpoint_current));
			等待直到 (!(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(主要攻击模式))), 真);
			"EditUpdateSelectedIds() # to arrow during the placement properly"
			While(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(主要攻击模式)));
				全局.H[全局.EditSelected] = 射线命中位置(眼睛位置(主机玩家), 眼睛位置(主机玩家) + 面朝方向(主机玩家) * 8, 空, 空, 假);
				等待(假, 无视条件);
			End;
			全局.EditorMoveItem = 真;
		Else If(主机玩家.editor_modeSelect == 2);
			修改全局变量(TQ, 添加至数组, 所选位置(主机玩家));
			修改全局变量(pinballnumber, 添加至数组, 主机玩家.checkpoint_current);
			修改全局变量(EditMode, 添加至数组, 10);
			修改全局变量(TQ5, 添加至数组, 假);
			修改全局变量(TQ6, 添加至数组, 假);
			修改全局变量(TQ7, 添加至数组, 假);
			修改全局变量(BounceToggleLock, 添加至数组, 假);
			调用子程序(EditUpdateSelectedIds);
			全局.EditSelected = 最后(全局.EditSelectIdArray);
			创建效果(已过滤的数组(添加至数组(所有玩家(所有队伍), 空), 当前数组元素.checkpoint_current == 全局.pinballnumber[单次赋值(全局.EditSelected)] && !数组包含(
				当前数组元素.cache_collectedLocks, 单次赋值(全局.EditSelected))), 球, 全局.BounceToggleLock[单次赋值(全局.EditSelected)
				] ? 全局.ColorConfig[16] : 全局.ColorConfig[15], 全局.TQ[单次赋值(全局.EditSelected)], 真, 可见，位置，半径和颜色);
			修改全局变量(TQ2, 添加至数组, 最后创建的实体);
			大字体信息(首个(真), 自定义字符串("{0} {1}", 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("新弹球已创建! \n仅生效于检查点") : 自定义字符串(
				"New Bounce Orb Created! \nOnly Valid For This Checkpoint"), 主机玩家.checkpoint_current));
			等待直到 (!(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(主要攻击模式))), 真);
			While(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(主要攻击模式)));
				全局.TQ[全局.EditSelected] = 射线命中位置(眼睛位置(主机玩家), 眼睛位置(主机玩家) + 面朝方向(主机玩家) * 7, 空, 空, 假);
				等待(假, 无视条件);
			End;
			全局.EditorMoveItem = 真;
		Else If(主机玩家.editor_modeSelect == 4);
			修改全局变量(CustomPortalStart, 添加至数组, 所选位置(主机玩家));
			修改全局变量(CustomPortalEndpoint, 添加至数组, 所选位置(主机玩家) + 10 * 上);
			修改全局变量(CustomPortalCP, 添加至数组, 主机玩家.checkpoint_current);
			调用子程序(EditUpdateSelectedIds);
			全局.EditSelected = 最后(全局.EditSelectIdArray);
			创建效果(已过滤的数组(所有玩家(所有队伍), 全局.CustomPortalCP[单次赋值(全局.EditSelected)] == 当前数组元素.checkpoint_current || 全局.CustomPortalCP[单次赋值(
				全局.EditSelected)] < 空), 有益光环, 全局.ColorConfig[17], 全局.CustomPortalStart[单次赋值(全局.EditSelected)], 0.600, 可见，位置，半径和颜色);
			修改全局变量(PortalEffects, 添加至数组, 最后创建的实体);
			全局.EditSelected = 数量(全局.CustomPortalStart) - 真;
			等待直到 (!(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(主要攻击模式))), 真);
			"EditUpdateSelectedIds()"
			While(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(主要攻击模式)));
				全局.CustomPortalStart[全局.EditSelected] = 射线命中位置(眼睛位置(主机玩家), 眼睛位置(主机玩家) + 面朝方向(主机玩家) * 6, 空, 空, 假);
				等待(假, 无视条件);
			End;
			大字体信息(首个(真), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("新传送门已创建!\n生效于当前检查点") : 自定义字符串("Portal Created \nOnly Valid For This Checkpoint"));
			全局.EditorMoveItem = 真;
		End;
		主机玩家.editor_lock = 假;
		等待(0.512, 无视条件);
	}
}

规则("Editor | Delete Cp/Orb/Portal")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Required for UpdateCache"
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		主机玩家.editor_lock == 假;
		按钮被按下(主机玩家, 按钮(互动)) == 真;
		按钮被按下(主机玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		"@Condition EditorMoveItem == false\n@Condition len(EditSelectIdArray) > 0"
		主机玩家.editor_lock = 真;
		If(!主机玩家.editor_modeSelect && 数量(全局.A));
			"Resync Kill Orbs =================="
			主机玩家.editor_temp = 已过滤的数组(映射的数组(全局.killballnumber, 当前数组元素 == 主机玩家.checkpoint_current ? 当前数组索引 : -1), 当前数组元素 >= 空);
			"hostPlayer.editor_temp = [i for e, i in KillballCheckpoints if e == hostPlayer.checkpoint_current]"
			For 全局变量(NANBA, 0, 数量(主机玩家.editor_temp), 真);
				消除效果(全局.K[主机玩家.editor_temp[全局.NANBA]]);
				修改全局变量(K, 根据索引从数组中移除, 主机玩家.editor_temp[全局.NANBA]);
				等待(假, 无视条件);
			End;
			修改全局变量(killballnumber, 根据值从数组中移除, 主机玩家.checkpoint_current);
			"Decrement checkpoints after removed one"
			全局.killballnumber = 映射的数组(全局.killballnumber, 当前数组元素 - (当前数组元素 > 主机玩家.checkpoint_current ? 1 : 空));
			"Remove Radii at Checkpoint indexes (temp)"
			全局.I = 已过滤的数组(全局.I, !数组包含(主机玩家.editor_temp, 当前数组索引));
			全局.H = 已过滤的数组(全局.H, !数组包含(主机玩家.editor_temp, 当前数组索引));
			"Resync Bounce Orbs =============="
			主机玩家.editor_temp = 已过滤的数组(映射的数组(全局.pinballnumber, 当前数组元素 == 主机玩家.checkpoint_current ? 当前数组索引 : -1), 当前数组元素 >= 空);
			"hostPlayer.editor_temp = [i for e, i in BouncePadCheckpoints if e == hostPlayer.checkpoint_current]"
			For 全局变量(NANBA, 0, 数量(主机玩家.editor_temp), 真);
				消除效果(全局.TQ2[主机玩家.editor_temp[全局.NANBA]]);
				修改全局变量(TQ2, 根据索引从数组中移除, 主机玩家.editor_temp[全局.NANBA]);
				等待(假, 无视条件);
			End;
			修改全局变量(pinballnumber, 根据值从数组中移除, 主机玩家.checkpoint_current);
			"Decrement checkpoints after removed one"
			全局.pinballnumber = 映射的数组(全局.pinballnumber, 当前数组元素 - (当前数组元素 > 主机玩家.checkpoint_current ? 1 : 空));
			全局.TQ = 已过滤的数组(全局.TQ, !数组包含(主机玩家.editor_temp, 当前数组索引));
			全局.EditMode = 已过滤的数组(全局.EditMode, !数组包含(主机玩家.editor_temp, 当前数组索引));
			全局.TQ5 = 已过滤的数组(全局.TQ5, !数组包含(主机玩家.editor_temp, 当前数组索引));
			全局.TQ6 = 已过滤的数组(全局.TQ6, !数组包含(主机玩家.editor_temp, 当前数组索引));
			全局.TQ7 = 已过滤的数组(全局.TQ7, !数组包含(主机玩家.editor_temp, 当前数组索引));
			全局.BounceToggleLock = 已过滤的数组(全局.BounceToggleLock, !数组包含(主机玩家.editor_temp, 当前数组索引));
			"Resync custom portals =================="
			主机玩家.editor_temp = 已过滤的数组(映射的数组(全局.CustomPortalCP, 当前数组元素 == 主机玩家.checkpoint_current ? 当前数组索引 : -1), 当前数组元素 >= 空);
			For 全局变量(NANBA, 0, 数量(主机玩家.editor_temp), 真);
				消除效果(全局.PortalEffects[主机玩家.editor_temp[全局.NANBA]]);
				修改全局变量(PortalEffects, 根据索引从数组中移除, 主机玩家.editor_temp[全局.NANBA]);
				等待(假, 无视条件);
			End;
			修改全局变量(CustomPortalCP, 根据值从数组中移除, 主机玩家.checkpoint_current);
			"Decrement checkpoints after removed one"
			全局.CustomPortalCP = 映射的数组(全局.CustomPortalCP, 当前数组元素 - (当前数组元素 > 主机玩家.checkpoint_current ? 1 : 空));
			"Remove Radii at Checkpoint indexes (temp)"
			全局.CustomPortalStart = 已过滤的数组(全局.CustomPortalStart, !数组包含(主机玩家.editor_temp, 当前数组索引));
			全局.CustomPortalEndpoint = 已过滤的数组(全局.CustomPortalEndpoint, !数组包含(主机玩家.editor_temp, 当前数组索引));
			主机玩家.editor_temp = 空;
			修改全局变量(Dao, 根据值从数组中移除, 主机玩家.checkpoint_current);
			全局.Dao = 映射的数组(全局.Dao, 当前数组元素 - (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
			修改全局变量(SHIFT, 根据值从数组中移除, 主机玩家.checkpoint_current);
			全局.SHIFT = 映射的数组(全局.SHIFT, 当前数组元素 - (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
			修改全局变量(Ability2, 根据值从数组中移除, 主机玩家.checkpoint_current);
			全局.Ability2 = 映射的数组(全局.Ability2, 当前数组元素 - (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
			修改全局变量(UnlimitAbilities, 根据值从数组中移除, 主机玩家.checkpoint_current);
			全局.UnlimitAbilities = 映射的数组(全局.UnlimitAbilities, 当前数组元素 - (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
			修改全局变量(BanStand, 根据值从数组中移除, 主机玩家.checkpoint_current);
			全局.BanDead = 映射的数组(全局.BanDead, 当前数组元素 - (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
			修改全局变量(BanBhop, 根据值从数组中移除, 主机玩家.checkpoint_current);
			全局.BanStand = 映射的数组(全局.BanStand, 当前数组元素 - (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
			修改全局变量(BanBhop, 根据值从数组中移除, 主机玩家.checkpoint_current);
			全局.BanBhop = 映射的数组(全局.BanBhop, 当前数组元素 - (当前数组元素 >= 主机玩家.checkpoint_current ? 1 : 空));
			修改全局变量(A, 根据索引从数组中移除, 主机玩家.checkpoint_current);
			主机玩家.checkpoint_current = 较大(主机玩家.checkpoint_current - 真, 假);
			调用子程序(RebuildKillOrbs);
			调用子程序(RebuildBounceOrbs);
			调用子程序(RebuildPortals);
			小字体信息(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   检查点已删除") : 自定义字符串("   Checkpoint Has Been Deleted"));
		Else If(主机玩家.editor_modeSelect == 1 && 数量(全局.EditSelectIdArray));
			修改全局变量(H, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(I, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(killballnumber, 根据索引从数组中移除, 全局.EditSelected);
			消除效果(全局.K[全局.EditSelected]);
			修改全局变量(K, 根据索引从数组中移除, 全局.EditSelected);
			调用子程序(RebuildKillOrbs);
		Else If(主机玩家.editor_modeSelect == 2 && 数量(全局.EditSelectIdArray));
			修改全局变量(TQ, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(EditMode, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(TQ5, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(TQ6, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(TQ7, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(BounceToggleLock, 根据索引从数组中移除, 全局.EditSelected);
			消除效果(全局.TQ2[全局.EditSelected]);
			修改全局变量(TQ2, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(pinballnumber, 根据索引从数组中移除, 全局.EditSelected);
			调用子程序(RebuildBounceOrbs);
		Else If(主机玩家.editor_modeSelect == 4 && 数量(全局.EditSelectIdArray));
			消除效果(全局.PortalEffects[全局.EditSelected]);
			等待(假, 无视条件);
			修改全局变量(CustomPortalStart, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(CustomPortalEndpoint, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(CustomPortalCP, 根据索引从数组中移除, 全局.EditSelected);
			修改全局变量(PortalEffects, 根据索引从数组中移除, 全局.EditSelected);
			调用子程序(RebuildPortals);
		Else;
			主机玩家.editor_lock = 假;
			等待(假, 无视条件);
			中止;
		End;
		调用子程序(UpdateCache);
		调用子程序(CheckpointFailReset);
		全局.EditSelected = 最后(全局.EditSelectIdArray);
		主机玩家.editor_lock = 假;
		等待(0.160 + 实体数量 * 0.007, 无视条件);
	}
}

规则("Editor | Toggle Orb Functions")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Required for UpdateCache"
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		主机玩家.editor_modeSelect == 2;
		主机玩家.editor_lock == 假;
		数量(全局.EditSelectIdArray) > 空;
		按钮被按下(主机玩家, 按钮(终极技能)) == 真;
		(按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(辅助攻击模式)) || 按钮被按下(主机玩家, 按钮(技能2)) || 按钮被按下(主机玩家, 按钮(互动)) || 按钮被按下(主机玩家, 按钮(装填))) == 真;
	}

	动作
	{
		主机玩家.editor_lock = 真;
		If(按钮被按下(主机玩家, 按钮(主要攻击模式)));
			全局.TQ5[全局.EditSelected] = !全局.TQ5[全局.EditSelected];
		Else If(按钮被按下(主机玩家, 按钮(辅助攻击模式)));
			全局.TQ6[全局.EditSelected] = !全局.TQ6[全局.EditSelected];
		Else If(按钮被按下(主机玩家, 按钮(技能2)));
			全局.TQ7[全局.EditSelected] = !全局.TQ7[全局.EditSelected];
		Else If(按钮被按下(主机玩家, 按钮(互动)));
			全局.BounceToggleLock[全局.EditSelected] = !全局.BounceToggleLock[全局.EditSelected];
			全局.EditMode[全局.EditSelected] = 10 * !全局.BounceToggleLock[全局.EditSelected];
		End;
		调用子程序(UpdateCache);
		主机玩家.editor_lock = 假;
		等待(假, 无视条件);
	}
}

规则("Editor | Orb Radii/Strength")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Required for UpdateCache"
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		数组包含(数组(1, 2), 主机玩家.editor_modeSelect) == 真;
		主机玩家.editor_lock == 假;
		数量(全局.EditSelectIdArray) > 空;
		按钮被按下(主机玩家, 按钮(技能2)) == 真;
		按钮被按下(主机玩家, 按钮(跳跃)) != 按钮被按下(主机玩家, 按钮(蹲下));
		按钮被按下(主机玩家, 按钮(互动)) == 假;
	}

	动作
	{
		主机玩家.editor_lock = 真;
		While(按钮被按下(主机玩家, 按钮(技能2)) && (按钮被按下(主机玩家, 按钮(跳跃)) || 按钮被按下(主机玩家, 按钮(蹲下))));
			If(主机玩家.editor_modeSelect == 2 && 数量(主机玩家.editor_bounceIndex));
				全局.EditMode[全局.EditSelected] += 按钮被按下(主机玩家, 按钮(跳跃)) ? 0.100 : -0.100;
			Else If(主机玩家.editor_modeSelect == 1 && 数量(主机玩家.editor_killIndex));
				全局.I[全局.EditSelected] += 按钮被按下(主机玩家, 按钮(跳跃)) ? 0.100 : -0.100;
			End;
			等待(0.128, 无视条件);
		End;
		调用子程序(UpdateCache);
		主机玩家.editor_lock = 假;
	}
}

规则("Editor | Select Orb/Portal")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"@Event eachPlayer\n@Condition eventPlayer == hostPlayer"
		全局.EditorOn != 假;
		数组包含(数组(1, 2, 4), 主机玩家.editor_modeSelect) == 真;
		主机玩家.editor_lock == 假;
		数量(全局.EditSelectIdArray) > 空;
		按钮被按下(主机玩家, 按钮(互动)) == 真;
		(按钮被按下(主机玩家, 按钮(蹲下)) || 按钮被按下(主机玩家, 按钮(跳跃))) == 真;
	}

	动作
	{
		主机玩家.editor_lock = 真;
		If(按钮被按下(主机玩家, 按钮(蹲下)));
			全局.EditSelected = 数组值的索引(全局.EditSelectIdArray, 全局.EditSelected) ? 全局.EditSelectIdArray[数组值的索引(全局.EditSelectIdArray,
				全局.EditSelected) - 真] : 最后(全局.EditSelectIdArray);
		Else;
			全局.EditSelected = 数组值的索引(全局.EditSelectIdArray, 全局.EditSelected) == 数量(全局.EditSelectIdArray) - 真 ? 首个(全局.EditSelectIdArray)
				: 全局.EditSelectIdArray[数组值的索引(全局.EditSelectIdArray, 全局.EditSelected) + 真];
		End;
		等待(假, 无视条件);
		主机玩家.editor_lock = 假;
		等待直到 (!(按钮被按下(主机玩家, 按钮(互动)) && (按钮被按下(主机玩家, 按钮(蹲下)) || 按钮被按下(主机玩家, 按钮(跳跃)))), 0.240);
	}
}

规则("Editor | Cp Size Hitbox Display")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"@Event eachPlayer\n@Condition eventPlayer == hostPlayer"
		全局.EditorOn != 假;
		主机玩家.editor_modeSelect == 空;
		按钮被按下(主机玩家, 按钮(互动)) == 真;
		按钮被按下(主机玩家, 按钮(技能1)) == 真;
	}

	动作
	{
		主机玩家.editor_hitboxToggle = !主机玩家.editor_hitboxToggle;
		等待(假, 无视条件);
	}
}

规则("Editor | Cp Add/Remove Teleport")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.EditorOn != 假;
		主机玩家.editor_modeSelect == 空;
		主机玩家.editor_lock == 假;
		数量(全局.A) > 真;
		按钮被按下(主机玩家, 按钮(互动)) == 真;
		按钮被按下(主机玩家, 按钮(装填)) == 真;
		按钮被按下(主机玩家, 按钮(近身攻击)) == 假;
	}

	动作
	{
		"prevent overlap with save map"
		等待直到 (按钮被按下(主机玩家, 按钮(近身攻击)) || !(按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(装填))), 真);
		根据条件中止(按钮被按下(主机玩家, 按钮(近身攻击)) || (按钮被按下(主机玩家, 按钮(互动)) && 按钮被按下(主机玩家, 按钮(装填))));
		主机玩家.editor_lock = 真;
		If(!主机玩家.checkpoint_current);
			小字体信息(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   不能在第一个检查点设置传送门") : 自定义字符串("   Cannot Place A Teleport On First Checkpoint"));
			主机玩家.editor_lock = 假;
			中止;
		End;
		"remove"
		If(数量(全局.A[主机玩家.checkpoint_current]) > 1);
			全局.A[主机玩家.checkpoint_current] = 首个(全局.A[主机玩家.checkpoint_current]);
			小字体信息(主机玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   关卡{0}的传送点已移除", 主机玩家.checkpoint_current) : 自定义字符串(
				"   Teleport For Level {0} Has Been Removed", 主机玩家.checkpoint_current));
		"add"
		Else;
			全局.A[主机玩家.checkpoint_current] = 数组(数量(全局.A[主机玩家.checkpoint_current]) ? 首个(全局.A[主机玩家.checkpoint_current])
				: 全局.A[主机玩家.checkpoint_current], 所选位置(主机玩家));
			小字体信息(主机玩家, 自定义字符串("{0} {1}", 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   传送点已添加到当前关卡") : 自定义字符串("   Teleport Has Been Added For Level"),
				主机玩家.checkpoint_current));
		End;
		主机玩家.editor_lock = 假;
		等待(假, 无视条件);
	}
}

规则("Editor | Moving Checkpoint")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"@Event eachPlayer\n@Condition eventPlayer == hostPlayer"
		全局.EditorOn != 假;
		主机玩家.editor_modeSelect == 空;
		主机玩家.editor_lock == 假;
		数量(全局.A) > 空;
		按钮被按下(主机玩家, 按钮(技能2)) == 真;
		按钮被按下(主机玩家, 按钮(辅助攻击模式)) == 假;
	}

	动作
	{
		等待(0.256, 当为“假”时中止);
		If(主机玩家.addon_toggle3rdPov);
			主机玩家.addon_toggle3rdPov = 假;
		End;
		主机玩家.editor_lock = 真;
		主机玩家.editor_undo = 全局.A[主机玩家.checkpoint_current];
		开始镜头(主机玩家, 眼睛位置(主机玩家) + 0.500 * 上 - 2.500 * 面朝方向(主机玩家), 眼睛位置(主机玩家), 15);
		While(按钮被按下(主机玩家, 按钮(技能2)) && 存活(主机玩家) && !按钮被按下(主机玩家, 按钮(辅助攻击模式)));
			If(按钮被按下(主机玩家, 按钮(主要攻击模式)));
				设置移动速度(主机玩家, 100);
			Else;
				设置移动速度(主机玩家, 3);
			End;
			If(数量(全局.A[主机玩家.checkpoint_current]));
				全局.A[主机玩家.checkpoint_current] = 数组(所选位置(主机玩家), 全局.A[主机玩家.checkpoint_current][真]);
			Else;
				全局.A[主机玩家.checkpoint_current] = 所选位置(主机玩家);
			End;
			等待(假, 无视条件);
		End;
		停止镜头(主机玩家);
		设置移动速度(主机玩家, 100);
		If(按钮被按下(主机玩家, 按钮(技能2)));
			全局.A[主机玩家.checkpoint_current] = 主机玩家.editor_undo;
			等待直到 (!按钮被按下(主机玩家, 按钮(技能2)), 999999995904.000);
		End;
		主机玩家.editor_lock = 假;
	}
}

规则("Editor | Toggle Ability")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		主机玩家.editor_modeSelect == 空;
		主机玩家.editor_lock == 假;
		数量(全局.A) > 空;
		(按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(辅助攻击模式)) || 按钮被按下(主机玩家, 按钮(技能2)) || 按钮被按下(主机玩家, 按钮(装填)) || 按钮被按下(主机玩家, 按钮(互动))) == 真;
		按钮被按下(主机玩家, 按钮(终极技能)) == 真;
	}

	动作
	{
		If(按钮被按下(主机玩家, 按钮(主要攻击模式)));
			If(数组包含(全局.Dao, 主机玩家.checkpoint_current));
				修改全局变量(Dao, 根据值从数组中移除, 主机玩家.checkpoint_current);
			Else;
				修改全局变量(Dao, 添加至数组, 主机玩家.checkpoint_current);
			End;
		Else If(按钮被按下(主机玩家, 按钮(辅助攻击模式)));
			If(数组包含(全局.SHIFT, 主机玩家.checkpoint_current));
				修改全局变量(SHIFT, 根据值从数组中移除, 主机玩家.checkpoint_current);
			Else;
				修改全局变量(SHIFT, 添加至数组, 主机玩家.checkpoint_current);
			End;
		Else If(按钮被按下(主机玩家, 按钮(技能2)));
			If(数组包含(全局.Ability2, 主机玩家.checkpoint_current));
				修改全局变量(Ability2, 根据值从数组中移除, 主机玩家.checkpoint_current);
			Else;
				修改全局变量(Ability2, 添加至数组, 主机玩家.checkpoint_current);
			End;
		Else If(按钮被按下(主机玩家, 按钮(互动)));
			If(数组包含(全局.UnlimitAbilities, 主机玩家.checkpoint_current));
				修改全局变量(UnlimitAbilities, 根据值从数组中移除, 主机玩家.checkpoint_current);
			Else;
				修改全局变量(UnlimitAbilities, 添加至数组, 主机玩家.checkpoint_current);
			End;
		End;
		等待(假, 无视条件);
	}
}

规则("Editor | Toggle Bans")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Required for UpdateCache"
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		主机玩家.editor_modeSelect == 3;
		主机玩家.editor_lock == 假;
		数量(全局.A) > 空;
		(按钮被按下(主机玩家, 按钮(跳跃)) || 按钮被按下(主机玩家, 按钮(蹲下)) || 按钮被按下(主机玩家, 按钮(终极技能))) == 真;
		按钮被按下(主机玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		主机玩家.editor_lock = 真;
		If(按钮被按下(主机玩家, 按钮(蹲下)));
			If(数组包含(全局.BanStand, 主机玩家.checkpoint_current));
				修改全局变量(BanStand, 根据值从数组中移除, 主机玩家.checkpoint_current);
			Else;
				修改全局变量(BanStand, 添加至数组, 主机玩家.checkpoint_current);
			End;
		Else If(按钮被按下(主机玩家, 按钮(跳跃)));
			If(数组包含(全局.BanBhop, 主机玩家.checkpoint_current));
				修改全局变量(BanBhop, 根据值从数组中移除, 主机玩家.checkpoint_current);
			Else;
				修改全局变量(BanBhop, 添加至数组, 主机玩家.checkpoint_current);
			End;
		Else;
			If(数组包含(全局.BanDead, 主机玩家.checkpoint_current));
				修改全局变量(BanDead, 根据值从数组中移除, 主机玩家.checkpoint_current);
			Else;
				修改全局变量(BanDead, 添加至数组, 主机玩家.checkpoint_current);
			End;
		End;
		"BanStand"
		等待(0.256, 无视条件);
		调用子程序(UpdateCache);
		主机玩家.editor_lock = 假;
	}
}

规则("Editor | Change Portal Cp")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		"@Event eachPlayer\n@Condition eventPlayer == hostPlayer"
		全局.EditorOn != 假;
		主机玩家.editor_modeSelect == 4;
		主机玩家.editor_lock == 假;
		数量(全局.EditSelectIdArray) > 空;
		按钮被按下(主机玩家, 按钮(跳跃)) == 真;
		按钮被按下(主机玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		全局.CustomPortalCP[全局.EditSelected] = 全局.CustomPortalCP[全局.EditSelected] < 空 ? 主机玩家.checkpoint_current : -1;
		等待(0.256, 无视条件);
	}
}

规则("Editor | Move Object")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Required for UpdateCache"
		事件玩家 == 主机玩家;
		全局.EditorOn != 假;
		数组包含(数组(1, 2, 4), 主机玩家.editor_modeSelect) == 真;
		主机玩家.editor_lock == 假;
		数量(全局.EditSelectIdArray) > 空;
		按钮被按下(主机玩家, 按钮(辅助攻击模式)) == 假;
		(全局.EditorMoveItem || (按钮被按下(主机玩家, 按钮(主要攻击模式)) && 按钮被按下(主机玩家, 按钮(技能2)))) == 真;
	}

	动作
	{
		主机玩家.editor_lock = 真;
		全局.EditorMoveItem = 真;
		If(主机玩家.addon_toggle3rdPov);
			主机玩家.addon_toggle3rdPov = 假;
		End;
		"hostPlayer.editor_fly = null"
		等待直到 (!(按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(技能2))), 999999995904.000);
		"hostPlayer.disallowButton(Button.ULTIMATE)\nhostPlayer.disallowButton(Button.JUMP)"
		设置状态(主机玩家, 空, 被入侵, 999999995904.000);
		设置移动速度(主机玩家, 假);
		"hostPlayer.startForcingPosition(hostPlayer.getPosition(), false)"
		If(主机玩家.editor_modeSelect == 1);
			主机玩家.editor_undo = 全局.H[全局.EditSelected];
			开始镜头(主机玩家, 全局.H[全局.EditSelected] + 面朝方向(主机玩家) * 绝对值(全局.I[全局.EditSelected]) * -1.500, 全局.H[全局.EditSelected], 30);
			While(!(按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(辅助攻击模式))));
				全局.H[全局.EditSelected] += (0.096 + 0.192 * 按钮被按下(事件玩家, 按钮(跳跃)) - 0.048 * 按钮被按下(事件玩家, 按钮(蹲下))) * (面朝方向(事件玩家) * Z方向分量(阈值(事件玩家)) * 矢量(
					真, !按钮被按下(事件玩家, 按钮(技能1)), 真) + 地图矢量(阈值(事件玩家) * 左, 事件玩家, 旋转) + 上 * (按钮被按下(事件玩家, 按钮(技能2)) - 按钮被按下(事件玩家, 按钮(终极技能))));
				等待(假, 无视条件);
			End;
		Else If(主机玩家.editor_modeSelect == 2);
			主机玩家.editor_undo = 全局.TQ[全局.EditSelected];
			开始镜头(主机玩家, 全局.TQ[全局.EditSelected] + 面朝方向(主机玩家) * -4, 全局.TQ[全局.EditSelected], 30);
			While(!(按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(辅助攻击模式))));
				全局.TQ[全局.EditSelected] += (0.096 + 0.192 * 按钮被按下(事件玩家, 按钮(跳跃)) - 0.048 * 按钮被按下(事件玩家, 按钮(蹲下))) * (面朝方向(事件玩家) * Z方向分量(阈值(事件玩家)) * 矢量(
					真, !按钮被按下(事件玩家, 按钮(技能1)), 真) + 地图矢量(阈值(事件玩家) * 左, 事件玩家, 旋转) + 上 * (按钮被按下(事件玩家, 按钮(技能2)) - 按钮被按下(事件玩家, 按钮(终极技能))));
				等待(假, 无视条件);
			End;
		Else If(主机玩家.editor_modeSelect == 4);
			主机玩家.editor_undo = 数组(全局.CustomPortalStart[全局.EditSelected], 全局.CustomPortalEndpoint[全局.EditSelected]);
			"move start position"
			开始镜头(主机玩家, 全局.CustomPortalStart[全局.EditSelected] + 面朝方向(主机玩家) * -4, 全局.CustomPortalStart[全局.EditSelected], 30);
			While(!(按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(辅助攻击模式))));
				全局.CustomPortalStart[全局.EditSelected] += (0.096 + 0.192 * 按钮被按下(事件玩家, 按钮(跳跃)) - 0.048 * 按钮被按下(事件玩家, 按钮(蹲下))) * (面朝方向(事件玩家) * Z方向分量(
					阈值(事件玩家)) * 矢量(真, !按钮被按下(事件玩家, 按钮(技能1)), 真) + 地图矢量(阈值(事件玩家) * 左, 事件玩家, 旋转) + 上 * (按钮被按下(事件玩家, 按钮(技能2)) - 按钮被按下(事件玩家, 按钮(
					终极技能))));
				等待(假, 无视条件);
			End;
			"move destination"
			开始镜头(主机玩家, 全局.CustomPortalEndpoint[全局.EditSelected] + 面朝方向(主机玩家) * -4, 全局.CustomPortalEndpoint[全局.EditSelected], 30);
			等待直到 (!按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(辅助攻击模式)), 真);
			While(!(按钮被按下(主机玩家, 按钮(主要攻击模式)) || 按钮被按下(主机玩家, 按钮(辅助攻击模式))));
				全局.CustomPortalEndpoint[全局.EditSelected] += (0.096 + 0.192 * 按钮被按下(事件玩家, 按钮(跳跃)) - 0.048 * 按钮被按下(事件玩家, 按钮(蹲下))) * (面朝方向(事件玩家)
					* Z方向分量(阈值(事件玩家)) * 矢量(真, !按钮被按下(事件玩家, 按钮(技能1)), 真) + 地图矢量(阈值(事件玩家) * 左, 事件玩家, 旋转) + 上 * (按钮被按下(事件玩家, 按钮(技能2)) - 按钮被按下(事件玩家,
					按钮(终极技能))));
				等待(假, 无视条件);
			End;
		End;
		If(按钮被按下(主机玩家, 按钮(辅助攻击模式)));
			跳过(2 * 主机玩家.editor_modeSelect);
		Else;
		Else;
			全局.H[全局.EditSelected] = 主机玩家.editor_undo;
		Else;
			全局.TQ[全局.EditSelected] = 主机玩家.editor_undo;
		Else;
		Else;
		Else;
			全局.CustomPortalStart[全局.EditSelected] = 首个(主机玩家.editor_undo);
			全局.CustomPortalEndpoint[全局.EditSelected] = 最后(主机玩家.editor_undo);
		End;
		主机玩家.editor_undo = 空;
		"hostPlayer.allowButton(Button.ULTIMATE)\nhostPlayer.allowButton(Button.JUMP)"
		清除状态(主机玩家, 被入侵);
		停止镜头(主机玩家);
		设置移动速度(主机玩家, 100);
		"hostPlayer.stopForcingPosition()"
		全局.EditorMoveItem = 空;
		调用子程序(UpdateCache);
		等待直到 (!按钮被按下(主机玩家, 按钮(主要攻击模式)), 真);
		主机玩家.editor_lock = 假;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Commands ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Command | Toggle Leaderboard (Hold Melee)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		数量(全局.LeaderBoardFull) > 空;
		全局.EditorOn == 假;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		事件玩家.maprating[0] != 真;
	}

	动作
	{
		等待(真, 当为“假”时中止);
		事件玩家.toggle_leaderboard = !事件玩家.toggle_leaderboard;
	}
}


规则("Command | Toggle Invisible (Hold Ultimate)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
		全局.EditorOn == 假;
		全局.CompMode == 假;
	}

	动作
	{
		等待(真, 当为“假”时中止);
		事件玩家.toggle_invisible = !事件玩家.toggle_invisible;
		设置不可见(事件玩家, 全部禁用);
		If(事件玩家.toggle_invisible);
			设置不可见(事件玩家, 全部);
		End;
		小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   {0} {1}", 自定义字符串("隐身模式"), 事件玩家.toggle_invisible ? 自定义字符串("启用") : 自定义字符串("关闭"))
			: 自定义字符串("   {0} {1}", 自定义字符串("Invisible"), 事件玩家.toggle_invisible ? 自定义字符串("On") : 自定义字符串("Off")));
		播放效果(事件玩家, 负面状态施加声音, 空, 事件玩家, 100);
	}
}

规则("Command | Preview Orbs & Portals (Hold Primary + Secondary)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"@Condition EditorOn == false"
		事件玩家.lockState == 假;
		事件玩家.checkpoint_notLast != 假;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
	}

	动作
	{
		等待(0.512, 当为“假”时中止);
		事件玩家.preview_array1 = 数组(首个(全局.A[事件玩家.checkpoint_current + 真]));
		If(数量(全局.pinballnumber));
			修改玩家变量(事件玩家, preview_array1, 添加至数组, 已过滤的数组(全局.TQ, 全局.pinballnumber[当前数组索引] == 事件玩家.checkpoint_current));
			修改玩家变量(事件玩家, preview_array2, 添加至数组, 已过滤的数组(映射的数组(全局.pinballnumber, 当前数组索引), 全局.pinballnumber[当前数组元素] == 事件玩家.checkpoint_current));
		End;
		If(数量(全局.CustomPortalStart));
			"eventPlayer.preview_array1.append( [i for i in CustomPortalStart if CustomPortalCP[CustomPortalStart.index(i)] == eventPlayer.checkpoint_current] )"
			For 玩家变量(事件玩家, preview_i, 0, 数量(事件玩家.cache_portalStart), 真);
				修改玩家变量(事件玩家, preview_array1, 添加至数组, 数组(事件玩家.cache_portalStart[事件玩家.preview_i], 事件玩家.cache_portalEnd[事件玩家.preview_i]));
				修改玩家变量(事件玩家, preview_array2, 添加至数组, 数组(数组(事件玩家.preview_i, 假), 数组(事件玩家.preview_i, 真)));
			End;
		End;
		等待(假, 无视条件);
		事件玩家.preview_i = 空;
		If(事件玩家.addon_toggle3rdPov);
			事件玩家.addon_toggle3rdPov = 假;
		End;
		开始镜头(事件玩家, 事件玩家.preview_array1[事件玩家.preview_i] + 上 - (3.500 - 3 * Z方向分量(阈值(事件玩家))) * 面朝方向(事件玩家),
			事件玩家.preview_array1[事件玩家.preview_i] + 上, 15);
		设置移动速度(事件玩家, 假);
		设置主要攻击模式启用(事件玩家, 假);
		设置辅助攻击模式启用(事件玩家, 假);
		禁用按钮(事件玩家, 按钮(技能1));
		禁用按钮(事件玩家, 按钮(跳跃));
		While(按钮被按下(事件玩家, 按钮(主要攻击模式)) && 按钮被按下(事件玩家, 按钮(辅助攻击模式)) && 存活(事件玩家) && !事件玩家.lockState);
			If(X方向分量(阈值(事件玩家)) < -0.500);
				事件玩家.preview_i += 真;
			Else If(X方向分量(阈值(事件玩家)) > 0.500);
				事件玩家.preview_i += 数量(事件玩家.preview_array1) - 真;
			End;
			事件玩家.preview_i %= 数量(事件玩家.preview_array1);
			等待直到 (绝对值(X方向分量(阈值(事件玩家))) < 0.500, 真);
			等待(假, 无视条件);
		End;
		设置主要攻击模式启用(事件玩家, 真);
		设置辅助攻击模式启用(事件玩家, 真);
		可用按钮(事件玩家, 按钮(技能1));
		可用按钮(事件玩家, 按钮(跳跃));
		停止镜头(事件玩家);
		设置移动速度(事件玩家, 100);
		事件玩家.preview_i = 空;
		事件玩家.preview_array1 = 空;
		事件玩家.preview_array2 = 空;
	}
}

规则("Command | Restart Run (Crouch + Interact + Deflect)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(!事件玩家.editor_lock || 事件玩家 != 主机玩家) == 真;
		事件玩家.lockState == 假;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
	}

	动作
	{
		事件玩家.lockState = 真;
		"prevent noise from Vendetta"
		If(!事件玩家.count_restart);
			等待(0.640, 无视条件);
		End;
		事件玩家.count_restart = 真;
		If(全局.CompMode);
			If(全局.CompTime < 1);
				小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   比赛结束") : 自定义字符串("   Competition Is Over"));
			Else If(全局.CompRestartLimit && 事件玩家.checkpoint_notLast);
				小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   禁止在此比赛中运行期间重新启动") : 自定义字符串(
					"   Restart During Run Is Disabled For This Competition"));
			Else If(全局.CompAtmpNum);
				If(事件玩家.comp_countAttempts == 全局.CompAtmpNum);
					小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   最后一次尝试") : 自定义字符串("   You Are On Your Final Attempt"));
				Else If(事件玩家.comp_countAttempts < 空);
					小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   你没有尝试过") : 自定义字符串("   You Are Out Of Attempts"));
				Else;
					事件玩家.comp_countAttempts += 真;
					全局.CompAtmpSaveCount[数组值的索引(全局.CompAtmpSaveNames, 字符串分割(首个(事件玩家), 空数组))] = 事件玩家.comp_countAttempts;
					跳过(5);
				End;
			End;
			事件玩家.lockState = 假;
			中止;
		End;
		事件玩家.editor_fly = 空;
		停止追踪玩家变量(事件玩家, timer_practice);
		If(数组包含(全局.SaveEnt, 事件玩家));
			调用子程序(DeleteSave);
		End;
		If(死亡(事件玩家));
			"eventPlayer.respawn()"
			复活(事件玩家);
			等待(真, 无视条件);
		End;
		调用子程序(StartGame);
		播放效果(事件玩家, 环状爆炸声音, 空, 事件玩家, 100);
		等待(全局.CompMode, 无视条件);
		"eventPlayer.allowButton(Button.ABILITY_1)"
		事件玩家.lockState = 假;
		"Anti spam"
		等待(0.128, 无视条件);
	}
}

规则("Command | Spectate (Hold Interact)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
		(全局.EditorOn && (按钮被按下(事件玩家, 按钮(近身攻击)) || 按钮被按下(事件玩家, 按钮(主要攻击模式)) || 按钮被按下(事件玩家, 按钮(辅助攻击模式)))) == 假;
	}

	动作
	{
		等待(真, 当为“假”时中止);
		"editor has interact combos"
		If(全局.EditorOn);
			等待(真, 当为“假”时中止);
		End;
		开启游戏预设复生模式(事件玩家);
		关闭游戏预设复生模式(事件玩家);
		If(事件玩家.toggle_spectate);
			复活(事件玩家);
			If(事件玩家.toggle_practice);
				追踪玩家变量频率(事件玩家, timer_practice, 999999995904.000, 真, 全部禁用);
			Else If(事件玩家.checkpoint_notLast);
				调用子程序(TimerResume);
			End;
			调用子程序(CheckpointFailReset);
		Else;
			事件玩家.toggle_invincible = 假;
			调用子程序(TimerPause);
			停止追踪玩家变量(事件玩家, timer_practice);
			设置受到伤害(事件玩家, 100);
			击杀(事件玩家, 空);
			设置受到伤害(事件玩家, 0);
			小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("   再次长按互动键关闭观战模式") : 自定义字符串("   Hold Interact Again To Turn Off Spectate Mode"));
		End;
		事件玩家.toggle_spectate = !事件玩家.toggle_spectate;
	}
}

规则("Command | Toggle Invincible Mode (Melee + Reload)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		(全局.CompMode && 事件玩家.comp_countAttempts < 空) == 假;
		事件玩家.lockState == 假;
		存活(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		事件玩家.lockState = 真;
		事件玩家.toggle_invincible = !事件玩家.toggle_invincible;
		If(事件玩家.toggle_invincible);
			大字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("探点模式") : 自定义字符串("Invincible Mode"));
			调用子程序(TimerPause);
			停止追踪玩家变量(事件玩家, timer_practice);
			调用子程序(ResetAbilities);
		Else;
			If(正在使用技能 2(事件玩家));
				开始强制设置玩家位置(事件玩家, 全局.A[事件玩家.checkpoint_current], 假);
				等待直到 (!正在使用技能 2(事件玩家), 99999);
				停止强制设置玩家位置(事件玩家);
			End;
			If(事件玩家.toggle_practice);
				大字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("练习模式") : 自定义字符串("Practice Mode"));
				追踪玩家变量频率(事件玩家, timer_practice, 999999995904.000, 真, 全部禁用);
				调用子程序(CheckpointFailReset);
			Else If(事件玩家.checkpoint_notLast);
				大字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("跑图模式") : 自定义字符串("Normal Mode"));
				调用子程序(TimerResume);
				调用子程序(CheckpointFailReset);
			End;
		End;
		事件玩家.lockState = 假;
		"Anti spam"
		等待(0.128, 无视条件);
	}
}

规则("Command | Toggle Practice Mode (Melee + Ultimate)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.EditorOn == 假;
		全局.CompMode == 假;
		事件玩家.lockState == 假;
		存活(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(装填)) == 假;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(终极技能)) == 真;
	}

	动作
	{
		事件玩家.lockState = 真;
		事件玩家.toggle_practice = !事件玩家.toggle_practice;
		If(事件玩家.toggle_practice);
			大字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("练习模式") : 自定义字符串("Practice Mode"));
			调用子程序(TimerPause);
			事件玩家.checkpoint_practice = 事件玩家.checkpoint_current;
			事件玩家.timer_practice = 空;
			追踪玩家变量频率(事件玩家, timer_practice, 999999995904.000, 真, 全部禁用);
			If(事件玩家.toggle_invincible);
				事件玩家.toggle_invincible = 假;
				调用子程序(CheckpointFailReset);
			End;
		Else;
			大字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("跑图模式") : 自定义字符串("Normal Mode"));
			停止追踪玩家变量(事件玩家, timer_practice);
			事件玩家.checkpoint_current = 事件玩家.checkpoint_practice;
			调用子程序(UpdateCache);
			If(事件玩家.checkpoint_notLast && !事件玩家.toggle_invincible);
				调用子程序(TimerResume);
				调用子程序(CheckpointFailReset);
			End;
		End;
		事件玩家.lockState = 假;
		"Anti spam"
		等待(0.128, 无视条件);
	}
}

规则("Command | Restart Practice (Hold Interact)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.EditorOn == 假;
		事件玩家.lockState == 假;
		事件玩家.toggle_practice != 假;
		(存活(事件玩家) || 事件玩家.toggle_spectate) == 真;
		按钮被按下(事件玩家, 按钮(互动)) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
		按钮被按下(事件玩家, 按钮(终极技能)) == 假;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 假;
		按钮被按下(事件玩家, 按钮(技能2)) == 假;
	}

	动作
	{
		"first 2 ifs prevent collide with spec"
		If(事件玩家.toggle_spectate);
			等待直到 (存活(事件玩家), 999999995904.000);
			等待直到 (!按钮被按下(事件玩家, 按钮(互动)), 2);
			中止;
		End;
		等待直到 (!按钮被按下(事件玩家, 按钮(互动)), 0.900);
		根据条件中止(按钮被按下(事件玩家, 按钮(互动)));
		事件玩家.timer_practice = 空;
		事件玩家.checkpoint_current = 事件玩家.checkpoint_practice;
		调用子程序(UpdateCache);
		调用子程序(CheckpointFailReset);
	}
}

规则("Command | Skip (Crouch + Primary-Next | Secondary-Previous)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		数量(全局.A) > 真;
		全局.EditorMoveItem == 假;
		(事件玩家.editor_lock && 事件玩家 == 主机玩家) == 假;
		(全局.EditorOn || 事件玩家.toggle_practice) == 真;
		事件玩家.lockState == 事件玩家.checkpoint_skip;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) != 按钮被按下(事件玩家, 按钮(辅助攻击模式));
	}

	动作
	{
		"@Condition hostPlayer.editor_on or ( eventPlayer.toggle_practice and eventPlayer.isHoldingButton(Button.ABILITY_1) )"
		事件玩家.lockState = 真;
		事件玩家.timer_practice = 空;
		事件玩家.checkpoint_current += 按钮被按下(事件玩家, 按钮(辅助攻击模式)) ? 数量(全局.A) - 真 : 真;
		事件玩家.checkpoint_current %= 数量(全局.A);
		事件玩家.checkpoint_moved = 真;
		"waitUntil(eventPlayer.isHoldingButton(Button.PRIMARY_FIRE) == eventPlayer.isHoldingButton(Button.SECONDARY_FIRE), 0.256) # faster if you spam button"
		If(事件玩家.checkpoint_skip);
			等待(0.320, 当为“真”时重新开始);
			调用子程序(UpdateCache);
			调用子程序(CheckpointFailReset);
		Else;
			事件玩家.checkpoint_skip = 真;
			调用子程序(UpdateCache);
			调用子程序(CheckpointFailReset);
			等待(0.480, 当为“真”时重新开始);
		End;
		事件玩家.checkpoint_skip = 假;
		事件玩家.lockState = 假;
		如条件为“真”则循环;
	}
}

规则("Command | Quick Reset (Reload | Hold Reload to Enable)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		按钮被按下(事件玩家, 按钮(装填)) == 真;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 假;
		按钮被按下(事件玩家, 按钮(互动)) == 假;
	}

	动作
	{
		If(事件玩家.toggle_quickRestart);
			If(事件玩家.editor_fly);
				事件玩家.editor_fly = 最后(全局.A[事件玩家.checkpoint_current]);
			End;
			调用子程序(CheckpointFailReset);
			等待(0.320, 无视条件);
		End;
		等待(真, 当为“假”时中止);
		事件玩家.toggle_quickRestart = !事件玩家.toggle_quickRestart;
		播放效果(事件玩家, 正面状态施加声音, 空, 事件玩家, 100);
		大字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? (事件玩家.toggle_quickRestart ? 自定义字符串("快速回点已启用") : 自定义字符串("快速回点已关闭")) : (
			事件玩家.toggle_quickRestart ? 自定义字符串("Quick Reset Is Enabled") : 自定义字符串("Quick Reset Is Disabled")));
	}
}

规则("Command | Toggle Hud (Hold Secondary)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.EditorMoveItem == 假;
		(全局.EditorOn && 事件玩家 == 主机玩家 && 按钮被按下(事件玩家, 按钮(近身攻击))) == 假;
		按钮被按下(事件玩家, 按钮(辅助攻击模式)) == 真;
		按钮被按下(事件玩家, 按钮(主要攻击模式)) == 假;
		"don't activate during skipping"
		按钮被按下(事件玩家, 按钮(蹲下)) == 假;
	}

	动作
	{
		等待(1.500, 当为“假”时中止);
		事件玩家.toggle_guide = !事件玩家.toggle_guide;
		小字体信息(事件玩家, 字符串("噢") == 自定义字符串("噢") ? (事件玩家.toggle_guide ? 自定义字符串("   HUD已隐藏") : 自定义字符串("   HUD已开启")) : (
			事件玩家.toggle_guide ? 自定义字符串("   HUD Is Now Hidden") : 自定义字符串("   HUD Is Now Shown")));
		播放效果(事件玩家, 正面状态施加声音, 空, 事件玩家, 100);
	}
}

规则("Command | Toggle Hints (Melee + Deflect)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.HintText != 空;
		按钮被按下(事件玩家, 按钮(近身攻击)) == 真;
		按钮被按下(事件玩家, 按钮(技能2)) == 真;
		(事件玩家.toggle_hints || 数组包含(全局.HintCp, 事件玩家.checkpoint_current)) == 真;
	}

	动作
	{
		事件玩家.toggle_hints = !事件玩家.toggle_hints;
	}
}

禁用 规则("Command | Toggle 3rd Person Camera (Hold Crouch + Jump)")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"True if not null"
		事件玩家.addon_toggle3rdPov <= 真;
		事件玩家.lockState == 假;
		事件玩家.editor_lock == 假;
		在地面上(事件玩家) == 真;
		按钮被按下(事件玩家, 按钮(蹲下)) == 真;
		按钮被按下(事件玩家, 按钮(跳跃)) == 真;
	}

	动作
	{
		等待(真, 当为“假”时中止);
		事件玩家.addon_toggle3rdPov = !事件玩家.addon_toggle3rdPov;
		调用子程序(Addon3rdPerson);
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Huds ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Huds | Global Localplayer")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待(0.768, 无视条件);
		"name/credit construction\nnote on changing default name/credit\nif you change it, also change it in the credits rule\nthe old credits should always remain valid here to keep old data valid"
		If(全局.Name == 自定义字符串("name here - 作者"));
			"Legacy Credits"
			全局.Name = 首个(全局.Cachedcredits);
		End;
		If(!全局.Name);
			全局.Name = 自定义字符串("name here - 作者");
		End;
		If(全局.Code == 自定义字符串("code here - 代码"));
			"Legacy Credits"
			全局.Code = 最后(全局.Cachedcredits);
		End;
		If(!全局.Code);
			全局.Code = 自定义字符串("code here - 代码");
		End;
		全局.Cachedcredits = 空;
		If(!全局.EditorOn);
			创建HUD文本(首个(真), 空, 本地玩家.toggle_guide ? 自定义字符串("{0}", 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0}\r斩仇帕克萌新群: 614016408{1}{1}", 英雄图标字符串(英雄(
				斩仇)), 图标字符串(火焰)) : 自定义字符串("斩仇跑酷萌新群: 614016408")) : 空数组, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串(
				"作者: {0}                                                                                                ", 全局.Name) : 自定义字符串(
				"Made By: {0}                                                                                                ", 全局.Name), 左边,
				-200, 空, 全局.ColorConfig[18], 首个(全局.ColorConfig), 可见和字符串, 默认可见度);
			创建HUD文本(首个(真), 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串(
				"代码: {0}                                                                                                ", 全局.Code) : 自定义字符串(
				"Map Code: {0}                                                                                                ", 全局.Code), 左边,
				-199, 空, 空, 全局.ColorConfig[真], 可见和字符串, 默认可见度);
			创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("长按 {0} + {1} | 预览关卡", 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(辅助攻击模式)))
				: 自定义字符串("Hold {0} + {1} | Preview CP", 输入绑定字符串(按钮(主要攻击模式)), 输入绑定字符串(按钮(辅助攻击模式))), 右边, -160, 空, 空, 本地玩家.preview_array1 ? 单次赋值(
				全局.ColorConfig[6]) : 单次赋值(全局.ColorConfig[5]), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(首个(本地玩家.preview_array1 && 本地玩家.toggle_guide), 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串(
				"移动键 ◀ ▶ | 预览其他\n移动键 ◀ ▶ | 修改间距 \n视角移动 | 调整浏览视角") : 自定义字符串(
				"Walk ◀ ▶ | Preview Others\nWalk ▲ ▼ | Modify Zoom\nAim | Change Preview Angle"), 空, 顶部, -171, 空, 全局.ColorConfig[6], 空, 可见和字符串,
				始终不可见);

			"Remove no hints - visual and element bloat"
			If(数量(全局.HintText));
				创建HUD文本(首个(本地玩家.toggle_guide && 数组包含(全局.HintCp, 本地玩家.checkpoint_current)), 空, 字符串("噢") == 自定义字符串("噢") ? (
					本地玩家.toggle_hints ? 自定义字符串("― ― ― ― ― 提示 ― ― ― ― ―\n {0} ", 全局.HintText[数组值的索引(全局.HintCp, 本地玩家.checkpoint_current)]) : 自定义字符串(
					"――――――  有可用提示 ――――――")) : (本地玩家.toggle_hints ? 自定义字符串("― ― ― ― ― Hint ― ― ― ― ―\n {0} ", 全局.HintText[数组值的索引(全局.HintCp,
					本地玩家.checkpoint_current)]) : 自定义字符串("― ― ― Hint Available ― ― ―")), 自定义字符串("{0} + {1} | {2}", 输入绑定字符串(按钮(技能2)), 输入绑定字符串(按钮(
					近身攻击)), 字符串("噢") == 自定义字符串("噢") ? (本地玩家.toggle_hints ? 自定义字符串("隐藏提示") : 自定义字符串("获取提示")) : (本地玩家.toggle_hints ? 自定义字符串(
					"Hide Hint") : 自定义字符串("Show Hint"))), 右边, -151, 空, 本地玩家.toggle_hints ? 颜色(绿色) : 颜色(橙色), 数组包含(全局.HintCp,
					本地玩家.checkpoint_current) ? 单次赋值(全局.ColorConfig[5]) : 颜色(灰色), 可见，字符串和颜色, 默认可见度);
			End;
			创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} + {2}", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(技能2)), 自定义字符串(
				"{0} | 重新开始\n长按 {1} | 完整成绩排名", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(近身攻击)))) : 自定义字符串("{0} + {1} + {2}", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(
				技能2)), 自定义字符串("{0} | Restart\nHold {1} | Leaderboard", 输入绑定字符串(按钮(互动)), 输入绑定字符串(按钮(近身攻击)))), 右边, -156, 空, 空, 全局.ColorConfig[5],
				可见和字符串, 默认可见度);
			全局.Difficultyhud = 数组(地图工坊设置组合(自定义字符串("Map Settings      ◆ 地图设置"), 自定义字符串("Difficulty 󠀨Display Hud󠀩     ◆ 难度 󠀨顶部hud󠀩"), 0, 数组(
				自定义字符串("<fg27AAFFFF>点击我选择难度 ◆ 目前难度：游戏测试"), 自定义字符串("<fgA0E81BFF>★☆☆☆☆☆☆☆☆☆"), 自定义字符串("<fgA0E81BFF>★★☆☆☆☆☆☆☆☆"), 自定义字符串(
				"<fge0e000FF>★★★☆☆☆☆☆☆☆"), 自定义字符串("<fge0e000FF>★★★★☆☆☆☆☆☆"), 自定义字符串("<fgEC9900FF>★★★★★☆☆☆☆☆"), 自定义字符串(
				"<fgEC9900FF>★★★★★★☆☆☆☆"), 自定义字符串("<fgFF4500FF>★★★★★★★☆☆☆"), 自定义字符串("<fgFF4500FF>★★★★★★★★☆☆"), 自定义字符串(
				"<fgC80013FF>★★★★★★★★★☆"), 自定义字符串("<fg960000FF>★★★★★★★★★★"), 自定义字符串("Do Not Display ◆ 不显示")), 1), 地图工坊设置开关(自定义字符串(
				"Map Settings      ◆ 地图设置"), 自定义字符串("Playtest Display        ◆ 游戏测试"), 假, 2));
			"display\n17th entry is 'dont display'"
			If(首个(全局.Difficultyhud) != 17);
				创建HUD文本(首个(本地玩家.toggle_guide && !本地玩家.toggle_leaderboard), 最后(全局.Difficultyhud) ? (字符串("噢") == 自定义字符串("噢") ? 自定义字符串("游戏测试")
					: 自定义字符串("Playtest")) : 空数组, 数组(自定义字符串("游戏测试"), 自定义字符串("★☆☆☆☆☆☆☆☆☆"), 自定义字符串("★★☆☆☆☆☆☆☆☆"), 自定义字符串("★★★☆☆☆☆☆☆☆"), 自定义字符串(
					"★★★★☆☆☆☆☆☆"), 自定义字符串("★★★★★☆☆☆☆☆"), 自定义字符串("★★★★★★☆☆☆☆"), 自定义字符串("★★★★★★★☆☆☆"), 自定义字符串("★★★★★★★★☆☆"), 自定义字符串("★★★★★★★★★☆"),
					自定义字符串("★★★★★★★★★★"), 空)[首个(全局.Difficultyhud)], 空, 顶部, -173, 颜色(蓝色), 数组(颜色(蓝色), 颜色(灰绿色), 颜色(灰绿色), 颜色(黄色), 颜色(黄色), 颜色(橙色), 颜色(
					橙色), 自定义颜色(255, 69, 0, 255), 自定义颜色(255, 69, 0, 255), 颜色(红色), 自定义颜色(150, 0, 0, 255), 自定义颜色(150, 0, 0, 255), 空)[首个(
					全局.Difficultyhud)], 空, 可见和字符串, 默认可见度);
			End;
			"top 5"
			创建HUD文本(本地玩家.toggle_guide && 全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][假] ? 本地玩家 : 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串(
				" \n{0} 排名前5 {0}", 图标字符串(旗帜)) : 自定义字符串(" \n{0} Top 5 {0}", 图标字符串(旗帜)), 空, 右边, -141, 空, 颜色(白色), 空, 可见和字符串, 始终可见);
			创建HUD文本(本地玩家.toggle_guide && 全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][假] ? 本地玩家 : 空, 英雄图标字符串(所用英雄(本地玩家)), 首个(首个(
				全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))])), 最后(首个(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))])), 右边, -140, 颜色(红色), 颜色(红色),
				颜色(红色), 可见和字符串, 始终可见);
			创建HUD文本(本地玩家.toggle_guide && 全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][真] ? 本地玩家 : 空, 英雄图标字符串(所用英雄(本地玩家)), 首个(
				全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][真]), 最后(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][真]), 右边, -139, 颜色(橙色), 颜色(
				橙色), 颜色(橙色), 可见和字符串, 始终可见);
			创建HUD文本(本地玩家.toggle_guide && 全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][2] ? 本地玩家 : 空, 英雄图标字符串(所用英雄(本地玩家)), 首个(
				全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][2]), 最后(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][2]), 右边, -138, 颜色(黄色), 颜色(
				黄色), 颜色(黄色), 可见和字符串, 始终可见);
			创建HUD文本(本地玩家.toggle_guide && 全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][3] ? 本地玩家 : 空, 英雄图标字符串(所用英雄(本地玩家)), 首个(
				全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][3]), 最后(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][3]), 右边, -137, 颜色(灰绿色), 颜色(
				灰绿色), 颜色(灰绿色), 可见和字符串, 始终可见);
			创建HUD文本(本地玩家.toggle_guide && 全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][4] ? 本地玩家 : 空, 英雄图标字符串(所用英雄(本地玩家)), 首个(
				全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][4]), 最后(全局.LeaderBoardFull[数组值的索引(全部英雄, 所用英雄(本地玩家))][4]), 右边, -136, 颜色(绿色), 颜色(
				绿色), 颜色(绿色), 可见和字符串, 始终可见);
			"leaderboard"
			创建HUD文本(本地玩家.toggle_leaderboard && 全局.LeaderBoardHuds[数组值的索引(全部英雄, 所用英雄(本地玩家))] ? 本地玩家 : 空, 自定义字符串(
				"　　　　 {0} {1} {0} 　　　　\n　　　　　　　　　　　　　　　　　　{2}", 图标字符串(旗帜), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("成绩排名") : 自定义字符串("Leaderboard"),
				全局.LeaderBoardHuds[数组值的索引(全部英雄, 所用英雄(本地玩家))]), 空, 空, 顶部, -165, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);
		End;
		"global huds"
		创建HUD文本(首个(真), 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("房间将在 {0} 分钟后重启 - v1.0.3A{1}", 全局.TimeRemaining, 文本数量 >= 128 ? 自定义字符串(
			"\n错误: 已达到最大HUD数量上限") : 空数组) : 自定义字符串("Server Restart In {0} Min - v1.0.3A{1}", 全局.TimeRemaining, 文本数量 >= 128 ? 自定义字符串(
			"\nError: Max HUD Count Reached") : 空数组), 空, 右边, -162, 空, 全局.ColorConfig[2], 空, 可见和字符串, 始终可见);
		"padding for custom hud display"
		创建HUD文本(首个(真), 空, 空, 自定义字符串("­\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"), 顶部,
			-164, 空, 空, 颜色(橙色), 可见, 默认可见度);
		创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} {1} | {2}快速回点", 本地玩家.toggle_quickRestart ? 空数组 : 自定义字符串(
			"长按"), 输入绑定字符串(按钮(装填)), 本地玩家.toggle_quickRestart ? 空数组 : 自定义字符串("启用")) : 自定义字符串("{0} {1} |{2} Quick Reset",
			本地玩家.toggle_quickRestart ? 空数组 : 自定义字符串("Hold"), 输入绑定字符串(按钮(装填)), 本地玩家.toggle_quickRestart ? 空数组 : 自定义字符串(" Enable")), 右边,
			-157, 空, 空, 全局.ColorConfig[5], 可见和字符串, 默认可见度);
		创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} | 探点模式{2}", 输入绑定字符串(按钮(装填)), 输入绑定字符串(按钮(近身攻击)),
			本地玩家.toggle_invincible ? 自定义字符串(" | 启用") : 空数组) : 自定义字符串("{0} + {1} | Invincible{2}", 输入绑定字符串(按钮(装填)), 输入绑定字符串(按钮(近身攻击)),
			本地玩家.toggle_invincible ? 自定义字符串(" | ON") : 空数组), 右边, -154, 空, 空, 本地玩家.toggle_invincible ? 单次赋值(全局.ColorConfig[6]) : 单次赋值(
			全局.ColorConfig[5]), 可见，字符串和颜色, 默认可见度);
		创建HUD文本(首个(真), 空, 本地玩家.toggle_guide ? 空数组 : 自定义字符串("{0}{1}{2}", 本地玩家.toggle_invincible ? 技能图标字符串(英雄(巴蒂斯特), 按钮(技能2)) : 空数组,
			本地玩家.toggle_practice ? 技能图标字符串(英雄(D.Va), 按钮(终极技能)) : 空数组, 本地玩家.toggle_invisible ? 技能图标字符串(英雄(黑影), 按钮(技能1)) : 空数组), 字符串("噢")
			== 自定义字符串("噢") ? 自定义字符串("长按 {0} | 切换显示HUD", 输入绑定字符串(按钮(辅助攻击模式))) : 自定义字符串("Hold {0} | Toggle Hud", 输入绑定字符串(按钮(辅助攻击模式))), 右边,
			-161, 空, 全局.ColorConfig[5], 全局.ColorConfig[5], 可见和字符串, 默认可见度);
		"text per checkpoint  text per cp each"
		If(数量(全局.CpHudText));
			创建HUD文本(首个(数组包含(全局.CpHudCp, 本地玩家.checkpoint_current) && 本地玩家.toggle_guide), 全局.CpHudText[数组值的索引(全局.CpHudCp,
				本地玩家.checkpoint_current)], 空, 空, 顶部, -169, 颜色(蓝色), 空, 空, 可见和字符串, 默认可见度);
		End;
		If(数量(全局.CpIwtText));
			创建地图文本(数组包含(全局.CpIwtCp, 本地玩家.checkpoint_current), 全局.CpIwtText[数组值的索引(全局.CpIwtCp, 本地玩家.checkpoint_current)], 全局.CpIwtPos[数组值的索引(
				全局.CpIwtCp, 本地玩家.checkpoint_current)], 2, 根据表面截取, 可见，位置和字符串, 全局.CpIwtColor, 默认可见度);
		End;
		If(全局.CompMode);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.comp_instructionHud), 自定义字符串(
				"                                                                                                                           "),
				空, 空, 顶部, -181, 颜色(白色), 空, 空, 可见, 默认可见度);
			If(首个(全局.instructiontext));
				创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.comp_instructionHud), 空, 空, 首个(全局.instructiontext), 顶部, -180, 空, 空, 颜色(白色), 可见, 默认可见度);
			End;
			If(全局.instructiontext[真]);
				创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.comp_instructionHud), 空, 空, 全局.instructiontext[真], 顶部, -179, 空, 空, 颜色(白色), 可见, 默认可见度);
			End;
			If(全局.instructiontext[2]);
				创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.comp_instructionHud), 空, 空, 全局.instructiontext[2], 顶部, -178, 空, 空, 颜色(白色), 可见, 默认可见度);
			End;
			If(全局.instructiontext[3]);
				创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.comp_instructionHud), 空, 空, 全局.instructiontext[3], 顶部, -177, 空, 空, 颜色(白色), 可见, 默认可见度);
			End;
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.comp_instructionHud), 自定义字符串(
				"                                   Press {0} to start                                ", 输入绑定字符串(按钮(互动))), 空, 空, 顶部, -176, 颜色(
				白色), 空, 空, 可见和字符串, 默认可见度);
		Else If(!全局.EditorOn);
			创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("长按 {0} | 隐身模式{1}", 输入绑定字符串(按钮(终极技能)),
				本地玩家.toggle_invisible ? 自定义字符串(" | 启用") : 空数组) : 自定义字符串("Hold {0} | Invisible{1}", 输入绑定字符串(按钮(终极技能)),
				本地玩家.toggle_invisible ? 自定义字符串(" | ON") : 空数组), 右边, -158, 空, 空, 本地玩家.toggle_invisible ? 单次赋值(全局.ColorConfig[6]) : 单次赋值(
				全局.ColorConfig[5]), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0} + {1} | 练习模式{2}", 输入绑定字符串(按钮(终极技能)), 输入绑定字符串(按钮(近身攻击)),
				本地玩家.toggle_practice ? 自定义字符串(" | ({0})", 本地玩家.checkpoint_practice) : 空数组) : 自定义字符串("{0} + {1} | Practice{2}", 输入绑定字符串(按钮(
				终极技能)), 输入绑定字符串(按钮(近身攻击)), 本地玩家.toggle_practice ? 自定义字符串(" | ({0})", 本地玩家.checkpoint_practice) : 空数组), 右边, -153, 空, 空,
				本地玩家.toggle_practice ? 单次赋值(全局.ColorConfig[6]) : 单次赋值(全局.ColorConfig[5]), 可见，字符串和颜色, 默认可见度);
			创建HUD文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.toggle_practice && 当前数组元素.toggle_guide), 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串(
				"{0} + {1} | 下一关\n{0} + {2}", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(主要攻击模式)), 自定义字符串("{0} | 上一关\n{1} | 回到练习模式起点 ", 输入绑定字符串(按钮(辅助攻击模式)),
				输入绑定字符串(按钮(互动)))) : 自定义字符串("{0} + {1} | Next Level\n{0} + {2}", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(主要攻击模式)), 自定义字符串(
				"{0} | Previous Level\n{1} | Restart Practice ", 输入绑定字符串(按钮(辅助攻击模式)), 输入绑定字符串(按钮(互动)))), 空, 右边, -152, 空, 单次赋值(
				全局.ColorConfig[6]), 空, 可见，字符串和颜色, 默认可见度);
			跳过(真);
		Else;
			创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("长按 {0} | 观战模式{1}", 输入绑定字符串(按钮(互动)),
				本地玩家.toggle_spectate ? 自定义字符串(" | 启用") : 空数组) : 自定义字符串("Hold {0} | Spectate{1}", 输入绑定字符串(按钮(互动)),
				本地玩家.toggle_spectate ? 自定义字符串(" | ON") : 空数组), 右边, -155, 空, 空, 本地玩家.toggle_spectate ? 单次赋值(全局.ColorConfig[6]) : 单次赋值(
				全局.ColorConfig[5]), 可见，字符串和颜色, 默认可见度);
		End;
		If(全局.maprating[0] && !全局.EditorOn);
			创建HUD文本(本地玩家.toggle_guide, 空, 自定义字符串("\n评分: {0} | 评分人数: {1}", 全局.maprating[2] / 全局.maprating[1], 全局.maprating[1]), 自定义字符串(
			"                                                                                                                                "),
			左边, -191, 空,颜色(白色), 空, 可见和字符串, 默认可见度);
		End;
	}
}

规则("Huds | Leaderboard")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.LeaderBoardRemake != 假;
		全局.LeaderBoardFull != 空数组;
	}

	动作
	{
		"account for delay in completion"
		等待(假, 无视条件);
		"top 5"
		全局.LeaderBoardFull[数组值的索引(全部英雄, 单次赋值(全局.LeaderBoardRemake))] = 已排序的数组(全局.LeaderBoardFull[数组值的索引(全部英雄, 单次赋值(全局.LeaderBoardRemake))],
			当前数组元素[真]);
		全局.LeaderBoardHuds[数组值的索引(全部英雄, 单次赋值(全局.LeaderBoardRemake))] = 映射的数组(全局.LeaderBoardFull[数组值的索引(全部英雄, 单次赋值(全局.LeaderBoardRemake))],
			自定义字符串("　 {0}:　{1} - {2}", 当前数组索引 + 真, 首个(当前数组元素), 最后(当前数组元素)));
		修改全局变量(LeaderBoardHuds, 添加至数组, 全局.LeaderBoardRemake);
		全局.LeaderBoardRemake = 空数组;
		While(数量(全局.LeaderBoardHuds[数组值的索引(全部英雄, 单次赋值(最后(全局.LeaderBoardHuds)))]));
			全局.LeaderBoardRemake = 自定义字符串("{0}\n{1}", 全局.LeaderBoardRemake, 首个(全局.LeaderBoardHuds[数组值的索引(全部英雄, 最后(全局.LeaderBoardHuds))]));
			全局.LeaderBoardHuds[数组值的索引(全部英雄, 最后(全局.LeaderBoardHuds))] = 已过滤的数组(全局.LeaderBoardHuds[数组值的索引(全部英雄, 最后(全局.LeaderBoardHuds))],
				当前数组索引 > 0);
		End;
		全局.LeaderBoardHuds[数组值的索引(全部英雄, 最后(全局.LeaderBoardHuds))] = 自定义字符串("{0}\n", 全局.LeaderBoardRemake);
		修改全局变量(LeaderBoardHuds, 根据值从数组中移除, 最后(全局.LeaderBoardHuds));
		全局.LeaderBoardRemake = 空;
		等待(假, 无视条件);
	}
}

规则("Huds | Each Player")
{
	事件
	{
		玩家加入比赛;
		双方;
		全部;
	}

	动作
	{
		等待(0.896, 无视条件);
		创建HUD文本(事件玩家, 空, 事件玩家.toggle_practice ? 自定义字符串("{0} {1} sec", 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("练习用时") : 自定义字符串("Practice Time:"),
			事件玩家.timer_practice) : 空数组, 自定义字符串(
			"{0} {1} sec                                                                                                ", 字符串("噢")
			== 自定义字符串("噢") ? 自定义字符串("用时") : 自定义字符串("Time:"), 事件玩家.timer_normal), 左边, -196, 空, 颜色(灰色), 全局.ColorConfig[3], 字符串, 默认可见度);
		创建HUD文本(事件玩家.toggle_leaderboard ? 空 : 事件玩家, 事件玩家.preview_array1 ? 自定义字符串(" {0} ({1}/{2}", 字符串("噢") == 自定义字符串("噢") ? (
			事件玩家.preview_i ? (事件玩家.preview_i <= 数量(事件玩家.cache_bouncePosition) ? 自定义字符串("弹球") : 自定义字符串("自定义传送门")) : 自定义字符串("检查点")) : (
			事件玩家.preview_i ? (事件玩家.preview_i <= 数量(事件玩家.cache_bouncePosition) ? 自定义字符串("orb") : 自定义字符串("portal")) : 自定义字符串("checkpoint")),
			事件玩家.preview_i + 真, 自定义字符串("{0})\n―――――――――――\n {1}\n", 数量(事件玩家.preview_array1), 事件玩家.preview_i <= 数量(
			事件玩家.cache_bouncePosition) && 事件玩家.preview_i ? 自定义字符串("{0} {1}", 自定义字符串("{0} {1}",
			全局.TQ6[事件玩家.preview_array2[事件玩家.preview_i]] ? 技能图标字符串(所用英雄(事件玩家), 按钮(技能1)) : 空数组,
			全局.TQ7[事件玩家.preview_array2[事件玩家.preview_i]] ? 技能图标字符串(所用英雄(事件玩家), 按钮(技能2)) : 空数组), 自定义字符串("{0} {1}",
			全局.BounceToggleLock[事件玩家.preview_array2[事件玩家.preview_i]] ? 图标字符串(警告) : 空数组,
			全局.EditMode[事件玩家.preview_array2[事件玩家.preview_i]] > 空 ? 图标字符串(箭头：向上) : (
			全局.EditMode[事件玩家.preview_array2[事件玩家.preview_i]] < 空 ? 图标字符串(箭头：向下) : 空数组))) : (事件玩家.preview_i ? (字符串("噢") == 自定义字符串("噢") ? (
			最后(事件玩家.preview_array2[事件玩家.preview_i]) ? 自定义字符串("传送门 {0} 出口 ", 事件玩家.preview_array2[事件玩家.preview_i]) : 自定义字符串("传送门 {0} 入口 ",
			事件玩家.preview_array2[事件玩家.preview_i])) : (最后(事件玩家.preview_array2[事件玩家.preview_i]) ? 自定义字符串("Portal {0} Exit ",
			事件玩家.preview_array2[事件玩家.preview_i]) : 自定义字符串("Portal {0} Start ", 事件玩家.preview_array2[事件玩家.preview_i]))) : 事件玩家.banString)))
			: 空数组, 事件玩家.preview_array1 ? 空数组 : 自定义字符串("{0}{1} {2}", 事件玩家.toggle_guide && 字符串长度(事件玩家.banString) ? 自定义字符串("{0}\n",
			事件玩家.banString) : 空数组, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("关卡") : 自定义字符串("Level"), 自定义字符串("{0} / {1}", 事件玩家.checkpoint_current,
			数量(全局.A) - 真)), 事件玩家.cache_bounceMaxLocks && !事件玩家.preview_array1 ? 自定义字符串("{0}{1} {2}", 全局.ColorConfig[16], 字符串("噢")
			== 自定义字符串("噢") ? 自定义字符串("球") : 自定义字符串(" Orbs"), 自定义字符串("{0} / {1}", 数量(事件玩家.cache_collectedLocks), 事件玩家.cache_bounceMaxLocks))
			: 空数组, 顶部, -172, 全局.ColorConfig[4], 全局.ColorConfig[4], 全局.ColorConfig[16], 可见和字符串, 默认可见度);
		创建HUD文本(事件玩家, 空, 空, 自定义字符串("{0}{1}{2}", X方向分量(事件玩家.cache_inputs) ? 自定义字符串("■") : 自定义字符串("□"), Z方向分量(阈值(事件玩家)) > 空 ? 自定义字符串("▲")
			: 自定义字符串("△"), 自定义字符串("{0}\n{1}{2}", Y方向分量(事件玩家.cache_inputs) ? 自定义字符串("●") : 自定义字符串("○"), X方向分量(阈值(事件玩家)) > 空 ? 自定义字符串("◀")
			: 自定义字符串("◁"), 自定义字符串("{0}{1}                                                                                                ",
			Z方向分量(阈值(事件玩家)) < 空 ? 自定义字符串("▼") : 自定义字符串("∇"), X方向分量(阈值(事件玩家)) < 空 ? 自定义字符串("▶") : 自定义字符串("▷")))), 左边, -192, 空, 空, 单次赋值(
			全局.ColorConfig[3]), 字符串, 默认可见度);
		"climb/bhop indicators"
		创建HUD文本(事件玩家, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("{0}{1}", 事件玩家.skill_usedBhop ? 自定义字符串("小跳已用") : 自定义字符串("小跳未用"),
			事件玩家.skill_countCreates ? 自定义字符串(" ({0})", 事件玩家.skill_countCreates) : 空数组) : 自定义字符串("Bhop{0}",
			事件玩家.skill_countCreates ? 自定义字符串(" ({0})", 事件玩家.skill_countCreates) : 空数组), 空, 自定义字符串(
			"                                                                                                                                "),
			左边, -194, 事件玩家.skill_usedBhop ? 单次赋值(全局.ColorConfig[8]) : 单次赋值(全局.ColorConfig[7]), 空, 空, 字符串和颜色, 默认可见度);
		创建地图文本(事件玩家.checkpoint_notLast && 事件玩家.toggle_guide ? 事件玩家 : 空, 事件玩家.cache_bounceMaxLocks && 数量(事件玩家.cache_collectedLocks)
			< 事件玩家.cache_bounceMaxLocks ? 自定义字符串("{0} {1}", 图标字符串(警告), 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("先收集{0}球", 全局.ColorConfig[16])
			: 自定义字符串("Collect Orbs First")) : (字符串("噢") == 自定义字符串("噢") ? 自定义字符串("到这里来") : 自定义字符串("come here")),
			全局.A[事件玩家.checkpoint_current + 真], 1.500, 不要截取, 可见，位置和字符串, 全局.ColorConfig[13], 默认可见度);
		"BE ID Title - 战网ID称号 <---- DISPLAY ID & Lvl"
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.toggle_guide && 当前数组元素 != 事件玩家), 自定义字符串("{0}{1}", 字符串分割(首个(事件玩家), 空数组),
			事件玩家.checkpoint_current ? 自定义字符串(" ({0})", 事件玩家.checkpoint_current) : 空数组), 2 * 上 + 事件玩家, 1, 根据表面截取, 可见，位置和字符串, 颜色(白色), 默认可见度);
		等待(2.500, 无视条件);
		If(全局.CompMode);
			创建HUD文本(事件玩家, 空, 字符串("噢") == 自定义字符串("噢") ? (全局.CompTime ? 自定义字符串("剩余时间: {0} 分钟{1}", 全局.CompTime,
				事件玩家.comp_countAttempts < 空 ? 自定义字符串("\n你没有尝试过") : (全局.CompAtmpNum ? 自定义字符串("\n尝试 {0} / {1}", 事件玩家.comp_countAttempts,
				全局.CompAtmpNum) : 空数组)) : 自定义字符串("! 比赛结束 !")) : (全局.CompTime ? 自定义字符串("Time Left: {0} min{1}", 全局.CompTime,
				事件玩家.comp_countAttempts < 空 ? 自定义字符串("\nYou Are Out Of Attempts") : (全局.CompAtmpNum ? 自定义字符串("\nAttempt {0} / {1}",
				事件玩家.comp_countAttempts, 全局.CompAtmpNum) : 空数组)) : 自定义字符串("! Competition Is Over !")), 字符串("噢") == 自定义字符串("噢") ? (
				全局.CompTime ? 自定义字符串("竞赛模式") : 自定义字符串("竞赛模式\n\n\n")) : (全局.CompTime ? 自定义字符串("Tournament Mode") : 自定义字符串(
				"Tournament Mode\n\n\n")), 顶部, -182, 空, 颜色(黄色), 颜色(黄色), 字符串, 默认可见度);
	}
}

规则("Huds | SUB Update Title")
{
	事件
	{
		子程序;
		UpdateTitle;
	}

	动作
	{
		"or eventPlayer.toggle_practice:"
		根据条件中止(全局.CompMode || 全局.EditorOn || !(数量(全局.TitleData) && 数组包含(首个(全局.TitleData), 事件玩家.checkpoint_current)));
		消除地图文本(事件玩家.cache_titleHud);
		创建地图文本(首个(!事件玩家.toggle_invisible), 全局.TitleData[真][数组值的索引(首个(全局.TitleData), 事件玩家.checkpoint_current)], 事件玩家, 1.100, 根据表面截取, 可见和位置,
			最后(全局.TitleData)[数组值的索引(首个(全局.TitleData), 事件玩家.checkpoint_current)], 默认可见度);
		事件玩家.cache_titleHud = 上一个文本ID;
	}
}

规则("Huds | Addons")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待(0.768, 无视条件);
		等待直到 (实体存在(所有玩家(所有队伍)), 999999995904.000);
		等待(假, 无视条件);
		If(所有玩家(所有队伍).addon_toggle3rdPov <= 真);
			创建HUD文本(本地玩家.toggle_guide, 空, 空, 字符串("噢") == 自定义字符串("噢") ? 自定义字符串("长按 {0} + {1} | 第三人称{2}", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(跳跃)),
				本地玩家.addon_toggle3rdPov ? 自定义字符串(" | 启用") : 空数组) : 自定义字符串("Hold {0} + {1} | 3rd Person{2}", 输入绑定字符串(按钮(蹲下)), 输入绑定字符串(按钮(跳跃)),
				本地玩家.addon_toggle3rdPov ? 自定义字符串(" | ON") : 空数组), 右边, -159, 空, 空, 本地玩家.addon_toggle3rdPov ? 单次赋值(全局.ColorConfig[6]) : 单次赋值(
				全局.ColorConfig[5]), 可见，字符串和颜色, 默认可见度);
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Effects ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Effects | Setup Effects")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"add back to below wait if removed"
		等待(2.048, 无视条件);
		"pre set control map portals. not in portal rule because shared I variable"
		If(数量(全局.PortalDest));
			For 全局变量(NANBA, 0, 数量(全局.PortalLoc), 真);
				创建效果(已过滤的数组(所有玩家(所有队伍), 当前数组元素.toggle_invincible || !当前数组元素.checkpoint_notLast), 有害光环, 全局.NANBA % 2 ? 颜色(水绿色) : 颜色(橙色),
					全局.PortalLoc[全局.NANBA], 0.600, 可见);
				创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.toggle_invincible || !当前数组元素.checkpoint_notLast), 全局.PortalNames[全局.NANBA],
					全局.PortalLoc[全局.NANBA] + 上, 真, 根据表面截取, 可见, 颜色(白色), 默认可见度);
			End;
			等待(假, 无视条件);
		End;
		If(全局.EditorOn);
			调用子程序(RebuildKillOrbs);
			调用子程序(RebuildBounceOrbs);
			调用子程序(RebuildPortals);
		Else;
			If(数量(全局.CustomPortalStart));
				For 全局变量(NANBA, 0, 数量(全局.CustomPortalStart), 真);
					创建效果(已过滤的数组(所有玩家(所有队伍), 当前数组元素.checkpoint_current == 单次赋值(全局.CustomPortalCP[全局.NANBA]) || 单次赋值(全局.CustomPortalCP[全局.NANBA] < 空)),
						有益光环, 全局.ColorConfig[17], 全局.CustomPortalStart[全局.NANBA], 0.600, 可见);
					等待(假, 无视条件);
				End;
				等待(0.512, 无视条件);
			End;
			If(数量(全局.H));
				For 全局变量(NANBA, 0, 数量(全局.H), 真);
					创建效果(已过滤的数组(所有玩家(所有队伍), 当前数组元素.checkpoint_current == 单次赋值(全局.killballnumber[全局.NANBA])), 球体, 全局.ColorConfig[14], 全局.H[全局.NANBA],
						绝对值(全局.I[全局.NANBA]), 可见);
					等待(假, 无视条件);
				End;
				等待(0.512, 无视条件);
			End;
			If(数量(全局.TQ));
				For 全局变量(NANBA, 0, 数量(全局.TQ), 真);
					创建效果(已过滤的数组(添加至数组(所有玩家(所有队伍), 空), 当前数组元素.checkpoint_current == 单次赋值(全局.pinballnumber[全局.NANBA]) && !数组包含(
						当前数组元素.cache_collectedLocks, 单次赋值(全局.NANBA))), 球, 全局.BounceToggleLock[全局.NANBA] ? 全局.ColorConfig[16] : 全局.ColorConfig[15],
						全局.TQ[全局.NANBA], 真, 可见);
					等待(假, 无视条件);
				End;
			End;
			"End portal preview"
			创建效果(本地玩家.preview_i && 本地玩家.preview_i > 数量(本地玩家.cache_bouncePosition) && 最后(本地玩家.preview_array2[本地玩家.preview_i]) ? 本地玩家 : 空, 火花,
				颜色(亮紫色), 本地玩家.preview_array1[本地玩家.preview_i], 0.500, 可见，位置和半径);
	}
}

规则("Effects | SUB Rebuild Bounce Orbs")
{
	事件
	{
		子程序;
		RebuildBounceOrbs;
	}

	动作
	{
		消除效果(全局.TQ2);
		全局.TQ2 = 空数组;
		For 全局变量(NANBA, 0, 数量(全局.pinballnumber), 真);
			创建效果(已过滤的数组(添加至数组(所有玩家(所有队伍), 空), 当前数组元素.checkpoint_current == 全局.pinballnumber[单次赋值(全局.NANBA)] && !数组包含(
				当前数组元素.cache_collectedLocks, 单次赋值(全局.NANBA))), 球, 全局.BounceToggleLock[单次赋值(全局.NANBA)
				] ? 全局.ColorConfig[16] : 全局.ColorConfig[15], 全局.TQ[单次赋值(全局.NANBA)], 真, 可见，位置，半径和颜色);
			修改全局变量(TQ2, 添加至数组, 最后创建的实体);
			"wait()"
			If(!(全局.NANBA % 5));
				等待(假, 无视条件);
			End;
		End;
	}
}

规则("Effects | SUB Rebuild boundary spheres")
{
	事件
	{
		子程序;
		RebuildKillOrbs;
	}

	动作
	{
		消除效果(全局.K);
		全局.K = 空数组;
		For 全局变量(NANBA, 0, 数量(全局.killballnumber), 真);
			创建效果(已过滤的数组(添加至数组(所有玩家(所有队伍), 空), 当前数组元素.checkpoint_current == 全局.killballnumber[单次赋值(全局.NANBA)]), 球体, 全局.ColorConfig[14],
				全局.H[单次赋值(全局.NANBA)], 绝对值(全局.I[单次赋值(全局.NANBA)]), 可见，位置和半径);
			修改全局变量(K, 添加至数组, 最后创建的实体);
			If(!(全局.NANBA % 5));
				等待(假, 无视条件);
			End;
		End;
	}
}

规则("Effects | SUB Rebuild Portals")
{
	事件
	{
		子程序;
		RebuildPortals;
	}

	动作
	{
		消除效果(全局.PortalEffects);
		全局.PortalEffects = 空数组;
		If(数量(全局.CustomPortalCP));
			For 全局变量(NANBA, 0, 数量(全局.CustomPortalCP), 真);
				创建效果(已过滤的数组(所有玩家(所有队伍), 当前数组元素.checkpoint_current == 全局.CustomPortalCP[单次赋值(全局.NANBA)] || 全局.CustomPortalCP[单次赋值(全局.NANBA)] < 空),
					有益光环, 全局.ColorConfig[17], 全局.CustomPortalStart[单次赋值(全局.NANBA)], 0.600, 可见，位置和半径);
				修改全局变量(PortalEffects, 添加至数组, 最后创建的实体);
				If(!(全局.NANBA % 5));
					等待(假, 无视条件);
				End;
			End;
		End;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Addon Functions ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Addon | Pre-set control Map Portal - Toggle Via Workshop Settings")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.PortalOn != 假;
		数量(全局.PortalLoc) != 空;
		(事件玩家.toggle_invincible || !事件玩家.checkpoint_notLast) == 真;
		对任意为“真”(全局.PortalLoc, 相距距离(当前数组元素, 所选位置(事件玩家) + 0.200 * 上) < 1.300) == 真;
	}

	动作
	{
		传送(事件玩家, 首个(已排序的数组(全局.PortalDest, 相距距离(事件玩家, 全局.PortalLoc[当前数组索引]))));
	}
}

规则("Addon | Custom Portals")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		数量(事件玩家.cache_portalStart) != 空;
		对任意为“真”(事件玩家.cache_portalStart, 相距距离(当前数组元素, 所选位置(事件玩家) + 0.200 * 上) < 1.300) == 真;
	}

	动作
	{
		传送(事件玩家, 首个(已排序的数组(事件玩家.cache_portalEnd, 相距距离(事件玩家, 事件玩家.cache_portalStart[当前数组索引]))));
		等待(0.512, 无视条件);
	}
}

规则("Addon | Preset Control Map Portal - Toggle Via Workshop Settings")
{
	事件
	{
		持续 - 全局;
	}

	条件
	{
		全局.PortalOn != 假;
	}

	动作
	{
		"wait(LoadOrder.portal) # overwrite pasta"
		If(当前地图 == 地图(釜山));
			"\"down > sanc\",\"down > meka\",\"sanc > down\",\"sanc > meka\",\"meka > sanc\",\"meka > down\""
			全局.PortalNames = 字符串分割(自定义字符串("Sanctuary0MEKA Base0Downtown0MEKA Base0Sanctuary0Downtown"), 首个(空));
			全局.PortalLoc = 数组(矢量(47.946, 7.248, -93.922), 矢量(55.921, 6.998, -94.024), 矢量(-326.382, 10.810, 117.261), 矢量(-330.960, 10.810,
				117.416), 矢量(219.567, 10.215, 243.653), 矢量(225.976, 10.227, 240.799));
			全局.PortalDest = 数组(矢量(-328.552, 10.010, 120.820), 矢量(221.152, 9.376, 238.765), 矢量(52.197, 6.301, -97.513), 矢量(221.271, 9.431,
				238.978), 矢量(-328.601, 10.010, 120.823), 矢量(52.197, 6.299, -97.513));
		Else If(当前地图 == 地图(伊利奥斯));
			"\"light > ruin\",\"light > well\",\"ruin > light\",\"ruin > well\",\"well > light\",\"well > ruin\""
			全局.PortalNames = 字符串分割(自定义字符串("Ruins0Well0Lighthouse0Well0Lighthouse0Ruins"), 首个(空));
			全局.PortalLoc = 数组(矢量(325.722, -22.665, -40.401), 矢量(327.430, -22.665, -36.089), 矢量(26.176, 58.367, -156.415), 矢量(30.472, 58.367,
				-156.307), 矢量(-199.945, 2.015, -2.918), 矢量(-194.930, 2.015, -8.054));
			全局.PortalDest = 数组(矢量(28.375, 57.659, -161.195), 矢量(-200.464, 1.306, -8.604), 矢量(333.088, -23.389, -40.933), 矢量(-200.464, 1.306,
				-8.604), 矢量(333.088, -23.389, -40.933), 矢量(28.375, 57.829, -161.195));
		Else If(当前地图 == 地图(漓江塔) || 当前地图 == 地图(春节漓江塔));
			"\"control > garden\",\"control > market\",\"garden > control\",\"garden > market\",\"market > control\",\"market > garden\""
			全局.PortalNames = 字符串分割(自定义字符串("Garden0Night Market0Control Center0Night Market0Control Center0Garden"), 首个(空));
			全局.PortalLoc = 数组(矢量(-2.815, 271, 295.373), 矢量(2.905, 271, 295.052), 矢量(5.788, 95.056, 135.298), 矢量(-5.343, 95.050, 134.638), 矢量(
				-2.738, 假, -61.911), 矢量(5.043, 假, -61.879));
			全局.PortalDest = 数组(矢量(0.286, 94.292, 140.396), 矢量(0.584, -0.709, -54.469), 矢量(0.245, 270.292, 301.428), 矢量(0.773, -0.708, -54.361),
				矢量(0.245, 270.292, 301.428), 矢量(0.286, 94.292, 140.396));
		Else If(当前地图 == 地图(尼泊尔));
			"\"vil > shrine\",\"vil > sanc\", \"shrine > vil\",\"shrine > sanc\",#\"sanc > vil\",\"sanc > shrine\""
			全局.PortalNames = 字符串分割(自定义字符串("Shrine0Sanctum0Village0Sanctum0Village0Shrine"), 首个(空));
			全局.PortalLoc = 数组(矢量(-194.732, -92.860, -3.802), 矢量(-194.585, -92.860, 4.187), 矢量(-33.165, 14, 5.212), 矢量(-33.058, 14, -5.550), 矢量(
				84.750, 129.008, -3.624), 矢量(84.534, 129, 4.032));
			全局.PortalDest = 数组(矢量(-40.190, 13.292, -0.105), 矢量(78.430, 128.292, 0.149), 矢量(-190.540, -93.569, 0.122), 矢量(78.430, 128.292,
				0.149), 矢量(-190.540, -93.569, 0.122), 矢量(-40.190, 13.292, -0.105));
		Else If(当前地图 == 地图(绿洲城));
			"\"uni > garden\",\"uni > city\",\"garden > uni\",\"garden > city\",\"city > garden\",\"city > uni\""
			全局.PortalNames = 字符串分割(自定义字符串("Gardens0City Center0University0City Center0Gardens0University"), 首个(空));
			全局.PortalLoc = 数组(矢量(-211.137, 20, -5.084), 矢量(-211.346, 20, 5.029), 矢量(143.061, 8.377, -245.040), 矢量(139.333, 8.377, -249.964),
				矢量(157.297, 12.522, 255.759), 矢量(151.452, 12.522, 261.099));
			全局.PortalDest = 数组(矢量(134.366, 7.829, -240.530), 矢量(158.270, 11.814, 262.272), 矢量(-206.269, 19.292, 0.103), 矢量(158.283, 11.814,
				262.283), 矢量(134.318, 7.829, -240.667), 矢量(-206.269, 19.292, 0.103));
		Else If(当前地图 == 地图(南极半岛));
			全局.PortalNames = 字符串分割(自定义字符串("Labs0Icebreaker0Sublevel0Icebreaker0Labs0Sublevel"), 首个(空));
			全局.PortalLoc = 数组(矢量(280.660, -12.150, -223.650), 矢量(273.270, 42.740, 198.150), 矢量(266.580, 42.740, 198.170), 矢量(-58.290, -154,
				63.030), 矢量(-58.360, -154, 56.470), 矢量(287.080, -12.150, -223.590));
			全局.PortalDest = 数组(矢量(270, 42.700, 190.440), 矢量(284.070, -12.750, -216.150), 矢量(-53.510, -154.500, 60.080), 矢量(284.070, -12.750,
				-216.150), 矢量(270, 42.700, 190.440), 矢量(-53.510, -154.500, 60.080));
		Else If(当前地图 == 地图(萨摩亚));
			全局.PortalNames = 字符串分割(自定义字符串("Beach0Volcano0Downtown0Volcano0Beach0Downtown"), 首个(空));
			全局.PortalLoc = 数组(矢量(231.980, 7.230, -262.840), 矢量(236.780, 7.230, -262.750), 矢量(-327.590, 3.600, -108.690), 矢量(-332.710, 3.600,
				-108.590), 矢量(25.400, 341, 354.380), 矢量(30, 341, 354.340));
			全局.PortalDest = 数组(矢量(-329.860, 3.050, -103.400), 矢量(27.590, 339.760, 348.770), 矢量(234.070, 6.120, -266.880), 矢量(27.590, 339.760,
				348.770), 矢量(-329.860, 3.050, -103.400), 矢量(234.070, 6.120, -266.880));
	}
}

规则("Addon | Little Destructo - Fence Breaker")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"Made by FishoFire version 1.0\nwait to overwrite any from copy pastas"
		等待(0.032, 无视条件);
		"first entry will act as index, rest is the points themselves"
		全局.MapVectorArray = 数组(空);
		"tdm/dm = first spawn points, the maps are not big so it just covers entire map. all teams defaults to team 1 spawn\npush: payload and cp 0 are set but rest isnt. normal payload maps have more then 1 point.\nrest of maps have up to 3 points"
		修改全局变量(MapVectorArray, 添加至数组, 当前游戏模式 == 游戏模式(勇夺锦旗) ? 数组(旗帜位置(队伍1), 旗帜位置(队伍2)) : (数组包含(数组(游戏模式(团队死斗), 游戏模式(死斗)), 当前游戏模式) ? 首个(重生点(
			所有队伍)) : (首个(运载目标位置) && !(目标位置(真) + 目标位置(2)) ? 运载目标位置 : 数组(目标位置(假), 目标位置(真), 目标位置(2)))));
		"explode in a grid around the selected points"
		While(数量(全局.MapVectorArray) > 1);
			全局.MapVectorArray[假] = 空;
			While(首个(全局.MapVectorArray) < 256);
				创建弹道(球弹道, 空, 全局.MapVectorArray[真] - 矢量(240, 假, 240) + 首个(全局.MapVectorArray) % 16 * 30 * 左 + 取整(首个(全局.MapVectorArray) / 16, 下)
					* 30 * 前, 下, 至地图, 治疗, 队伍1, 0, 0, 30, 有益爆炸, 爆炸声音, 1, 1, 0, 0, 0, 0);
				全局.MapVectorArray[假] += 真;
				"use modulo to only wait every x orbs keep the 0 change the other number"
				If(!(首个(全局.MapVectorArray) % 3));
					等待(假, 无视条件);
				End;
			End;
			修改全局变量(MapVectorArray, 根据索引从数组中移除, 真);
		End;
		"handle exceptions (looking at you new queen street)"
		全局.MapVectorArray = 数组(矢量(8.276, 4.113, 15.261), 矢量(-8.319, 2.624, 14.245), 矢量(0.006, 4.821, 18.513));
		While(数量(全局.MapVectorArray));
			"same as other projectile before"
			创建弹道(球弹道, 空, 首个(全局.MapVectorArray), 下, 至地图, 治疗, 队伍1, 0, 0, 30, 有益爆炸, 爆炸声音, 1, 1, 0, 0, 0, 0);
			修改全局变量(MapVectorArray, 根据索引从数组中移除, 假);
			等待(假, 无视条件);
		End;
		全局.MapVectorArray = 空;
	}
}

规则("Addon | Caching Jump & Crouch Inputs For Spectators")
{
	事件
	{
		玩家加入比赛;
		双方;
		全部;
	}

	动作
	{
		等待(假, 无视条件);
		事件玩家.cache_inputs = 矢量(按钮被按下(事件玩家, 按钮(跳跃)), 按钮被按下(事件玩家, 按钮(蹲下)), 假);
		循环;
	}
}

规则("Addon | SUB 3rd Person Camera")
{
	事件
	{
		子程序;
		Addon3rdPerson;
	}

	动作
	{
		If(事件玩家.addon_toggle3rdPov);
			开始镜头(事件玩家, 逐帧更新(射线命中位置(0.500 * 上 + 眼睛位置(事件玩家), 0.500 * 上 + 眼睛位置(事件玩家) + -3.500 * 面朝方向(事件玩家), 空数组, 空数组, 假) + 0.500 * 面朝方向(事件玩家)),
				逐帧更新(0.500 * 上 + 眼睛位置(事件玩家)), 假);
		Else;
			停止镜头(事件玩家);
		End;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Map Data & Addon Settings Are On Page 2 - 地图数据和附加组件的设置在第2页 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Ø Map Data - 数据录入 <---- INSERT HERE / 在这输入")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{

	}
}

规则("☞ Credits and Colors here - 作者代码HUD颜色 <---- INSERT HERE / 在这输入")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待(假, 无视条件);
		"Filling this in adds it to the inspector pasta after next restart.\nYou can fill in again to overwrite.\n修改的内容 在重新开始 比赛后生效\n您可以反复 修改字符串 中的内容"
		全局.Name = 自定义字符串("name here - 作者");
		全局.Code = 自定义字符串("code here - 代码");
		"+++++  +++++  +++++  +++++  +++++  +++++\ncolor customization below / 自定义 颜色(实体、HUD)\n+++++  +++++  +++++  +++++  +++++  +++++\n\ncredit hud name   -   作者HUD"
		全局.ColorConfig[假] = 颜色(天蓝色);
		"credit hud code   -   代码HUD"
		全局.ColorConfig[真] = 颜色(天蓝色);
		"dsc.gg/genjiparkour"
		全局.ColorConfig[18] = 颜色(绿色);
		"server time hud   -   房间倒计时"
		全局.ColorConfig[2] = 颜色(红色);
		"time  hud   -   单关用时HUD"
		全局.ColorConfig[3] = 颜色(白色);
		"level hud   -   关卡HUD"
		全局.ColorConfig[4] = 颜色(白色);
		"command hud   -   指令HUD"
		全局.ColorConfig[5] = 颜色(白色);
		"command hud highlight   -   指令HUD高亮"
		全局.ColorConfig[6] = 颜色(绿色);
		"bhop/climb available   -   小跳/爬墙未用HUD"
		全局.ColorConfig[7] = 颜色(绿色);
		"bhop/climb used (cant be same as available)   -   小跳/爬墙已用HUD"
		全局.ColorConfig[8] = 颜色(红色);
		"current checkpoint ring   -   当前检查点光圈"
		全局.ColorConfig[9] = 颜色(天蓝色);
		"next checkpoint ring   -   下一关检查点光圈"
		全局.ColorConfig[10] = 颜色(灰绿色);
		"next checkpoint light shaft   -   下一关检查点光柱"
		全局.ColorConfig[11] = 颜色(白色);
		"next checkpoint icon   -   下一关检查点图标"
		全局.ColorConfig[12] = 颜色(天蓝色);
		"\"come here\" text   -   到这里来\" 文本"
		全局.ColorConfig[13] = 颜色(白色);
		"kill orbs   -   击杀球"
		全局.ColorConfig[14] = 颜色(蓝色);
		"normal orbs   -   弹球"
		全局.ColorConfig[15] = 颜色(绿色);
		"lock orbs (overwritten if its same as normal)\n收集球 (与普通弹 球相同时将 自动覆写)"
		全局.ColorConfig[16] = 颜色(橙色);
		"portals   -   自定义 传送门"
		全局.ColorConfig[17] = 颜色(白色);
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Addons Settings & Data - 附加组件 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

规则("Addon | Comp Mode Instruction Message - 竞赛模式指引消息 <---- INSERT HERE / 在这输入")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待(0.400, 无视条件);
		"Instructions that show when you start comp mode.\nDue to the hud text limit, you there is 4 huds available.\nIf you dont need a field just empty the textfield."
		中止;
		"竞赛模式 指引消息\n指引消息将 会在竞赛模 式开始时 显示\n由于 hud 文本限制，你有 4 个hud可用\n如果你不需 要一个字段 只是空文 本字段"
		全局.instructiontext = 数组(自定义字符串("Change in Comp Mode instruction message hud 1"), 自定义字符串(
			"Change in Comp Mode instruction message hud 2"), 自定义字符串("Change in Comp Mode instruction message hud 3"), 自定义字符串(
			"Change in Comp Mode instruction message hud 4"));
	}
}

规则("Addon | Custom Difficulty Hud - 自定义难度hud <---- INSERT HERE / 在这输入")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"1) workshop settings > difficulty > set to \"dont display\"\n2) enable this rule\n3) type your difficulty in the hud below"
		等待(2.500, 无视条件);
		"1) 地图工坊设 置难度改为 “不显示”\n2) 勾选此规则 点击上方的 开启/关闭 开启此规则\n3) 修改下面的 创建hud文本 中的“enter custom difficulty here”"
		创建HUD文本(首个(真), 最后(全局.Difficultyhud) ? (字符串("噢") == 自定义字符串("噢") ? 自定义字符串("游戏测试") : 自定义字符串("Playtest")) : 空数组, 自定义字符串("{0} {1} {2}",
			英雄图标字符串(英雄(斩仇)), 图标字符串(红桃), 英雄图标字符串(英雄(安娜))), 空, 顶部, -173, 颜色(蓝色), 颜色(绿色), 空, 可见和字符串, 默认可见度);
	}
}

规则("Addon | HUD | All Players Current Checkpiont <---- 玩家当前所在关数")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		等待(0.800, 无视条件);
		If(!全局.EditorOn);
			创建HUD文本(本地玩家.toggle_guide, 空, 自定义字符串("{0}{1} ", 所有玩家(所有队伍)[0] ? 自定义字符串("\n{0}:  {1}", 所有玩家(所有队伍)[0], 所有玩家(所有队伍)
				[0].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[1] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[1], 所有玩家(所有队伍)
				[1].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[2] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[2], 所有玩家(所有队伍)
				[2].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[3] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[3], 所有玩家(所有队伍)
				[3].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[4] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[4], 所有玩家(所有队伍)
				[4].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[5] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[5], 所有玩家(所有队伍)
				[5].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[6] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[6], 所有玩家(所有队伍)
				[6].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[7] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[7], 所有玩家(所有队伍)
				[7].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[8] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[8], 所有玩家(所有队伍)
				[8].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[9] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[9], 所有玩家(所有队伍)
				[9].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}{1}", 所有玩家(所有队伍)[10] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[10], 所有玩家(所有队伍)
				[10].checkpoint_current) : 自定义字符串(""), 自定义字符串("{0}", 所有玩家(所有队伍)[11] ? 自定义字符串("\n{0}: {1}", 所有玩家(所有队伍)[11], 所有玩家(所有队伍)
				[11].checkpoint_current) : 自定义字符串(""))))))))))))), 自定义字符串(
				"                                                                                                                                "),
				左边, -190, 空, 自定义颜色(255, 200, 254, 255), 空, 可见和字符串, 默认可见度);
	}
}

禁用 规则("Addon | Title Data - 标题数据 <---- EDIT ME / 在此处编辑")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"enable this rule and fill in the title data below.\n启用此规则 并填写下面 的标题数据"
		等待(0.640, 无视条件);
		"checkpoint number\n每关数量"
		全局.TitleData[假] = 数组(空, 10, 20, 30, 40, 50);
		"title\n标题文本"
		全局.TitleData[真] = 数组(自定义字符串("Bunny"), 自定义字符串("Jumper"), 自定义字符串("Ninja"), 自定义字符串("Pro"), 自定义字符串("Expert"), 自定义字符串("Master"));
		"color\n颜色"
		全局.TitleData[2] = 数组(颜色(灰绿色), 颜色(白色), 颜色(黄色), 颜色(橙色), 颜色(亮紫色), 颜色(红色));
	}
}

禁用 规则("Addon | Friend Title - 朋友称号 <---- DISPLAY MESSAGE HERE (ON PLAYER)")
{
	事件
	{
		玩家加入比赛;
		双方;
		全部;
	}

	动作
	{
		"\"your nickname\" your friends ingame name\n\"display title\" fill in the custom title\n修改字符串 \"your nickname <-------\" 为好友名字 区分大小写\n修改字符串 \"display title\" 为好友头顶 显示的称号"
		等待直到 (已重生(事件玩家), 999999995904.000);
		If(自定义字符串("Your Nickname <-------") == 字符串分割(首个(事件玩家), 空数组));
			大字体信息(首个(真), 自定义字符串("Message To The Whole Room"));
			创建地图文本(首个(!事件玩家.toggle_invisible), 自定义字符串("Display Title"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		End;
		If(自定义字符串("Your Nickname <-------") == 字符串分割(首个(事件玩家), 空数组));
			大字体信息(首个(真), 自定义字符串("Message To The Whole Room"));
			创建地图文本(首个(!事件玩家.toggle_invisible), 自定义字符串("Display Title"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
		End;
		If(自定义字符串("Your Nickname <-------") == 字符串分割(首个(事件玩家), 空数组));
			大字体信息(首个(真), 自定义字符串("Message To The Whole Room"));
			创建地图文本(首个(!事件玩家.toggle_invisible), 自定义字符串("Display Title"), 事件玩家, 1.500, 根据表面截取, 可见，位置和字符串, 颜色(橙色), 默认可见度);
	}
}

禁用 规则("Addon | Display Author Time - 展示世界纪录 <---- EDIT ME / 在此处编辑")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"type your entry in the textfield that says \"Name and Time here\"\n在文本框 中输入“名称和时间”"
		创建HUD文本(首个(真), 空, 自定义字符串(" \n{0} Author Time {0}", 图标字符串(火焰)), 自定义字符串("Name and Time here"), 右边, -142, 空, 颜色(玫红), 颜色(玫红), 可见,
			默认可见度);
	}
}

禁用 规则("Addon | HUD Text For Certain Checkpoints - 特定关卡显示的HUD文本 <---- EDIT ME / 在此处编辑")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"the example fill shows a text for cp 1 and cp 3\n示例已填写 关卡1和3 的hud文本"
		等待(0.640, 无视条件);
		"in CpHudText fill in text\n修改字符串 “CpHudText” 为顶部显示 的hud文本"
		全局.CpHudText = 数组(自定义字符串("text cp 1"), 自定义字符串("text cp 3"));
		"in CpHudCp fill in the at wich to display\n修改数组 “CpHudCp” 为hud文本 显示的关卡"
		全局.CpHudCp = 数组(1, 3);
	}
}

禁用 规则("Addon | In-World Text For Certain Checkpoints - 特定关卡显示的地图文本 <---- EDIT ME / 在此处编辑")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"the example fill shows a text for cp 1 and cp 3\n示例已填写 关卡1和3 的地图文本"
		等待(0.640, 无视条件);
		"in CpIwtText fill in text\n修改字符串 “CpIwtText” 为关卡显示 的地图文本"
		全局.CpIwtText = 数组(自定义字符串("text cp 1"), 自定义字符串("text cp 3"));
		"in CpIwtCp fill in cp at wich to display\n修改数组 “CpIwtCp” 为显示地图 文本的关卡"
		全局.CpIwtCp = 数组(1, 3);
		"in CpIwtPos fill in the vector\n修改数组 “CpIwtPos” 为地图文本 的矢量位置"
		全局.CpIwtPos = 数组(矢量(真, 真, 真), 矢量(真, 真, 真));
		"color applies to all\n选择应用到 所有地图文 本的颜色"
		全局.CpIwtColor = 颜色(灰绿色);
	}
}

禁用 规则("Addon | Hint Text For Certain Checkpoints - 特定关卡的提示文本 <---- EDIT ME / 在此处编辑")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"the example fill shows a text for cp 1 and cp 3\n示例已填写 关卡1和3 的提示文本"
		等待(0.640, 无视条件);
		"in HintText fill in text\n修改字符串 “HintText” 为关卡显示 的提示文本"
		全局.HintText = 数组(自定义字符串("text cp 1"), 自定义字符串("text cp 3"));
		"in HintCp fill in the at wich to display\n修改数组 “HintCp” 为提示文本 显示的关卡"
		全局.HintCp = 数组(1, 3);
	}
}

规则("Addon | MapRating | HUD")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		全局.maprating[0] == 真;
		事件玩家.maprating[0] == 真;
		存活(事件玩家) == 真;
	}

	动作
	{
		"maprating 0评分状态  1评分值  2HUDID"

		事件玩家.toggle_leaderboard = 假;
        事件玩家.maprating[1] = 3;


        创建HUD文本(事件玩家, 自定义字符串(
            "\n\n\n\n\n　　　　      地图评分             　　\n\n\n\n\n　　　　 你的评分: {1} / 5\n\n\n\n\n\n    方向键A / D调整           {0}确认\n\n\n\n\n\n",
        输入绑定字符串(按钮(互动)), 事件玩家.maprating[1]), 空, 空, 顶部, -165, 颜色(白色), 空, 空, 可见和字符串, 默认可见度);

        事件玩家.maprating[2] = 上一个文本ID;
        
        等待直到(按钮被按下(事件玩家, 按钮(互动)), 99999);

        事件玩家.maprating[0] = 假;
		"全局.maprating    0开关   1评分人数  2总评分  3已评价的人"
		全局.maprating[3] = 添加至数组(全局.maprating[3], 首个(事件玩家));
        

        全局.maprating[1] += 1;
        全局.maprating[2] += 事件玩家.maprating[1];

        消除HUD文本(事件玩家.maprating[2]);

	}
}

规则("Addon | MapRating | Choose Rating")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		事件玩家.maprating[0] == 真;
		X方向分量(阈值(事件玩家)) != 空;
	}

	动作
	{
		If(X方向分量(阈值(事件玩家)) > 空 && 事件玩家.maprating[1] >= 1);
			事件玩家.maprating[1] -= 1;
		Else If(X方向分量(阈值(事件玩家)) < 空 && 事件玩家.maprating[1] <= 4);
			事件玩家.maprating[1] += 1;
		End;
        等待(0.160, 无视条件);
        如条件为“真”则循环;
	}
}

禁用 规则("Addon | 3rd Person Camera Mode - 第三人称")
{
	事件
	{
		玩家加入比赛;
		双方;
		全部;
	}

	动作
	{
		"Default 1st person: False\nDefault 3rd person: True"
		事件玩家.addon_toggle3rdPov = 真;
		调用子程序(Addon3rdPerson);
	}
}

规则("▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒ Addons Skills - 附加组件技能 ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒")
{
	事件
	{
		持续 - 全局;
	}
}

禁用 规则("Addon | Stall Enhancer - 增强系統跳的判定")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		已重生(事件玩家) == 真;
		垂直速度(事件玩家) >= -0.200;
		垂直速度(事件玩家) <= 0.050;
		水平速度(事件玩家) <= 1.300;
		正在空中(事件玩家) == 真;
		全局.EditorOn != 假;
		事件玩家.editor_fly == 假;
	}

	动作
	{
		等待(0.250, 当为“假”时中止);
		开始强制设置玩家位置(事件玩家, 所选位置(事件玩家), 假);
		等待直到 (!正在移动(事件玩家), 1);
		停止强制设置玩家位置(事件玩家);
		设置移动速度(事件玩家, 假);
		设置引力(事件玩家, 假);
		"double jump catch"
		等待直到 (按钮被按下(事件玩家, 按钮(装填)) || 事件玩家.editor_fly || 死亡(事件玩家) || 正在使用技能 1(事件玩家) || 速度(事件玩家) > 3, 3);
		"wait(3)"
		设置引力(事件玩家, 100);
		设置移动速度(事件玩家, 100);
		If(存活(事件玩家) && !(事件玩家.editor_fly || 按钮被按下(事件玩家, 按钮(装填))));
			施加推力(事件玩家, 上, 10, 至地图, 取消相反运动XYZ);
			如条件为“真”则循环;
	}
}

禁用 规则("Addon | Group up - Map Data")
{
	事件
	{
		持续 - 全局;
	}

	动作
	{
		"replace 777 with checkpoint number\nreplace vector 0,0,0 with orb position"
		创建地图文本(已过滤的数组(所有玩家(所有队伍), 当前数组元素.checkpoint_current == 777), 自定义字符串("{0} {1} {0}", 技能图标字符串(所用英雄(本地玩家), 按钮(终极技能)), 字符串("噢")
			== 自定义字符串("噢") ? 自定义字符串("待在这里") : 自定义字符串("Group Up")), 矢量(真, 真, 真), 1.500, 不要截取, 可见和字符串, 颜色(橙色), 默认可见度);
		"replace 777 with checkpoint number\nreplace vector 0,0,0 with orb position\n3.5 is the radius"
		创建效果(已过滤的数组(所有玩家(所有队伍), 当前数组元素.checkpoint_current == 777), 球体, 颜色(橙色), 矢量(真, 真, 真), 3.500, 可见);
	}
}

禁用 规则("Addon | Group Up")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"replace 777 with checkpoint number"
		事件玩家.checkpoint_current == 777;
		存活(事件玩家) == 真;
		在地面上(事件玩家) == 假;
		事件玩家.toggle_invincible == 假;
		"replace vector 0,0,0 with orb position\n3.5 is the radius"
		相距距离(事件玩家, 矢量(真, 真, 真)) < 3.500;
	}

	动作
	{
		小字体信息(事件玩家, 自定义字符串("   Stay Within Bubble"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   9"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   8"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   7"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   6"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   5"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   4"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   3"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   2"));
		等待(真, 当为“假”时中止);
		小字体信息(事件玩家, 自定义字符串("   1"));
		等待(真, 当为“假”时中止);
		开始强制设置玩家位置(事件玩家, 全局.A[事件玩家.checkpoint_current + 真] + 0.100 * 上, 假);
		设置状态(事件玩家, 空, 定身, 0.300);
		等待(0.112, 无视条件);
		停止强制设置玩家位置(事件玩家);
	}
}

禁用 规则("Addon | Custom Checkpoint Loading or Resetting")
{
	事件
	{
		子程序;
		AddonCustomLoadAndReset;
	}

	动作
	{
		"This subroutine activates on failing, arriving, resetting, skipping etc\nexample: reset gravity and movespeed after being changed by custom orbs"
		设置引力(事件玩家, 100);
		设置移动速度(事件玩家, 100);
		清除状态(事件玩家, 相移);
	}
}

禁用 规则("Addon | Custom Orb Script")
{
	事件
	{
		持续 - 每名玩家;
		双方;
		全部;
	}

	条件
	{
		"Do not edit this condition !!!!!!!!!!!!!!!!!"
		事件玩家.cache_bounceTouched >= 空;
	}

	动作
	{
		"Note that the ID can change if you place or delete orbs infront of that orb.\nAdd the desired ID numbers for the orb in the array\nAdd the script after it\nyou can use the activateed sub above this rule to reset the effects"
		If(数组包含(数组(1, 2), 事件玩家.cache_bounceTouched));
			"example gravity (should be reset to 100 in AddonCustomLoadAndReset)"
			设置引力(事件玩家, 25);
			小字体信息(事件玩家, 自定义字符串(" You Feel Light"));
			等待(2, 无视条件);
			设置引力(事件玩家, 100);
		End;
		If(数组包含(数组(3, 4), 事件玩家.cache_bounceTouched));
			"example canceling primary"
			取消主要动作(事件玩家);
		End;
		If(数组包含(数组(5, 6), 事件玩家.cache_bounceTouched));
			"example move speed"
			设置移动速度(事件玩家, 250);
			小字体信息(事件玩家, 自定义字符串(" Zooom"));
			等待(2, 无视条件);
			设置移动速度(事件玩家, 100);
	}
}